import { createFetch, ofetch, FetchError } from 'ofetch';

async function wait(duration) {
  return new Promise((res) => {
    setTimeout(() => {
      res(true);
    }, duration);
  });
}

function messageListFromString(input) {
  const messages = [];
  let line = "";
  let ignoreNextNewline = false;
  let data;
  let id;
  let event;
  let retry;
  let previousChar;
  let pendingIndex = 0;
  let isEndOfMessage = false;
  function handleParseLine(pIndex) {
    const result = parseLine(line);
    data = result.data ?? data;
    id = result.id ?? id;
    event = result.event ?? event;
    retry = result.retry ?? retry;
    if (isEndOfMessage) {
      if (typeof data === "string") {
        messages.push({
          id,
          data,
          event: event ?? "message",
          retry
        });
      }
      id = void 0;
      data = void 0;
      event = void 0;
      retry = void 0;
      pendingIndex = pIndex;
    }
    line = "";
  }
  for (let i = 0; i < input.length; i++) {
    const char = input[i];
    switch (char) {
      case "\r": {
        isEndOfMessage = previousChar === "\n" || previousChar === "\r";
        ignoreNextNewline = true;
        const pIndex = input[i + 1] === "\n" ? i + 2 : i + 1;
        handleParseLine(pIndex);
        break;
      }
      case "\n": {
        if (ignoreNextNewline) {
          ignoreNextNewline = false;
          break;
        }
        isEndOfMessage = previousChar === "\n";
        handleParseLine(i + 1);
        break;
      }
      default:
        line += char;
        break;
    }
    previousChar = char;
  }
  return {
    messages,
    leftoverData: input.substring(pendingIndex)
  };
}
function parseLine(input) {
  if (input.startsWith("data:")) {
    return { data: input.substring(5).trim() };
  }
  if (input.startsWith("id:")) {
    return { id: input.substring(3).trim() };
  }
  if (input.startsWith("event:")) {
    return {
      event: input.substring(6).trim()
    };
  }
  if (input.startsWith("retry:")) {
    const val = Number(input.substring(6).trim());
    if (!Number.isNaN(val)) {
      if (Number.isInteger(val)) {
        return { retry: val };
      } else {
        return { retry: Math.round(val) };
      }
    }
  }
  return {};
}
async function getBytes(controller, stream, onChunk) {
  const reader = stream.getReader();
  let result;
  while (!controller.signal.aborted && !(result = await reader.read()).done) {
    onChunk(result.value);
  }
}

const EventStreamContentType = "text/event-stream";
const LastEventIdHeader = "last-event-id";
class EventSourcePlus {
  url;
  lastEventId;
  options;
  retryCount = 0;
  retryInterval = 0;
  maxRetryCount;
  maxRetryInterval;
  fetch;
  timeoutDurationMs;
  timeout;
  constructor(url, options = {}) {
    this.url = url;
    this.options = options;
    this.maxRetryCount = options.maxRetryCount;
    this.maxRetryInterval = options.maxRetryInterval ?? 3e4;
    this.fetch = createFetch({ fetch: options.fetch }) ?? ofetch;
    this.timeoutDurationMs = options.timeout;
  }
  async _handleRetry(controller, hooks) {
    this.retryCount++;
    if (typeof this.maxRetryCount === "number" && this.retryCount >= this.maxRetryCount) {
      controller._emitEvent({
        type: "error",
        reason: "max retry count reached"
      });
      return;
    }
    if (this.retryInterval === 0) {
      this.retryInterval = 2;
    } else if (this.retryInterval > 0) {
      this.retryInterval = this.retryInterval * 2;
      if (this.retryInterval >= this.maxRetryInterval) {
        this.retryInterval = this.maxRetryInterval;
      }
    }
    await wait(this.retryInterval);
    controller._abortController.abort();
    controller._abortController = new AbortController();
    await this._handleConnection(controller, hooks);
  }
  async _handleConnection(controller, hooks) {
    let headers;
    const abortSignal = controller._abortController.signal;
    if (typeof this.options.headers === "function") {
      const result = this.options.headers();
      if ("then" in result && typeof result.then === "function") {
        headers = new Headers(
          await result.then((data) => data)
        );
      } else {
        headers = new Headers(result);
      }
    } else {
      headers = new Headers(
        this.options.headers ?? {}
      );
    }
    if (typeof headers.get("accept") !== "string") {
      headers.set("accept", EventStreamContentType);
    }
    if (typeof this.lastEventId === "string") {
      headers.set(LastEventIdHeader, this.lastEventId);
    }
    let ctx;
    const finalOptions = {
      ...this.options,
      method: this.options.method ?? "get",
      responseType: "stream",
      headers,
      signal: abortSignal,
      retry: false,
      onRequest: (context) => {
        if (controller.signal.aborted || abortSignal.aborted) return;
        if (isAbortError(context.error)) return;
        return hooks.onRequest?.(context);
      },
      onRequestError: async (context) => {
        if (controller.signal.aborted || abortSignal.aborted) return;
        if (isAbortError(context.error)) return;
        return hooks.onRequestError?.(context);
      },
      onResponse: async (context) => {
        ctx = context;
        return _handleResponse(context, hooks);
      },
      onResponseError: async (context) => {
        if (abortSignal.aborted) return;
        if (isAbortError(context.error)) return;
        if (typeof context.error === "undefined") {
          context.error = new FetchError(
            `${context.response.status} ${context.response.statusText}`
          );
        }
        await hooks.onResponseError?.(context);
        throw context.error;
      }
    };
    try {
      if (this.timeoutDurationMs) {
        this.timeout = setTimeout(() => {
          controller._emitEvent({
            type: "error",
            reason: `Timeout of ${this.timeoutDurationMs}ms exceeded`
          });
        }, this.timeoutDurationMs);
      }
      const response = await this.fetch.raw(this.url, finalOptions);
      clearTimeout(this.timeout);
      this.timeout = void 0;
      this.retryCount = 0;
      this.retryInterval = 0;
      const decoder = new TextDecoder();
      let pendingData = "";
      const stream = response.body;
      if (!stream) {
        const error = new Error(
          `Expected response body to contain ReadableStream`
        );
        ctx.response = response;
        ctx.error = error;
        await hooks.onResponseError?.(ctx);
        throw error;
      }
      await getBytes(controller, stream, (arr) => {
        const text = pendingData + decoder.decode(arr, { stream: true });
        const result = messageListFromString(text);
        pendingData = result.leftoverData ?? "";
        for (const message of result.messages) {
          if (typeof message.id === "string" && message.id.length > 0) {
            this.lastEventId = message.id;
          }
          hooks.onMessage(message);
        }
      });
    } catch (err) {
      if (abortSignal.aborted || controller.signal.aborted || isAbortError(err)) {
        return;
      }
      return this._handleRetry(controller, hooks);
    }
    if (controller.signal.aborted || abortSignal.aborted) {
      return;
    }
    if (this.options.retryStrategy === "on-error") {
      controller._emitEvent({
        type: "end-of-stream",
        reason: "Stream has ended"
      });
      return;
    }
    return this._handleRetry(controller, hooks);
  }
  listen(hooks) {
    const controller = new EventSourceController(
      new AbortController(),
      (newHooks) => {
        if (typeof newHooks === "undefined") {
          void this._handleConnection(controller, hooks);
          return;
        }
        void this._handleConnection(controller, {
          ...hooks,
          ...newHooks
        });
      }
    );
    void this._handleConnection(controller, hooks);
    return controller;
  }
}
function isAbortError(input) {
  return input instanceof DOMException && input.name === "AbortError";
}
class EventSourceController {
  didAbort = false;
  /**
   * Do not modify. For internal use.
   */
  _abortController;
  _connect;
  constructor(controller, connect) {
    this._abortController = controller ?? new AbortController();
    this._connect = connect;
  }
  abort(reason) {
    this._emitEvent({ type: "manual", reason });
  }
  reconnect(hooks) {
    this.didAbort = false;
    this._abortController.abort();
    this._abortController = new AbortController();
    void this._connect?.(hooks);
  }
  _abortHook;
  _emitEvent(e) {
    if (this.didAbort) return;
    this.didAbort = true;
    this._abortHook?.(e);
    this._abortController.abort(e.reason);
  }
  onAbort(fn) {
    this._abortHook = fn;
  }
  get signal() {
    return this._abortController.signal;
  }
}
const HTTP_METHOD_VALS = [
  "get",
  "head",
  "post",
  "put",
  "delete",
  "connect",
  "options",
  "trace",
  "patch"
];
async function _handleResponse(context, hooks) {
  if (typeof hooks.onResponse === "function") {
    await hooks.onResponse(context);
  }
  if (!context.response.ok) {
    return;
  }
  const contentType = context.response.headers.get("Content-Type");
  if (typeof contentType !== "string" || !contentType.includes(EventStreamContentType)) {
    const error = new Error(
      `Expected server to response with Content-Type: '${EventStreamContentType}'. Got '${contentType}'`
    );
    context.error = error;
    if (typeof hooks.onResponseError === "function") {
      await hooks.onResponseError(context);
    }
    throw error;
  }
}

export { EventSourceController, EventSourcePlus, EventStreamContentType, HTTP_METHOD_VALS, _handleResponse, getBytes, messageListFromString, parseLine };
