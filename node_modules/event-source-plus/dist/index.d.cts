import { Fetch, $Fetch, FetchContext, FetchResponse } from 'ofetch';

interface SseMessage {
    id?: string;
    event: string;
    data: string;
    retry?: number;
}
declare function messageListFromString(input: string): {
    messages: SseMessage[];
    leftoverData: string | undefined;
};
declare function parseLine(input: string): Partial<SseMessage>;
declare function getBytes(controller: AbortController, stream: ReadableStream<Uint8Array>, onChunk: (arr: Uint8Array) => void): Promise<void>;

declare const EventStreamContentType = "text/event-stream";
declare class EventSourcePlus {
    url: string;
    lastEventId: string | undefined;
    options: EventSourcePlusOptions;
    retryCount: number;
    retryInterval: number;
    maxRetryCount: number | undefined;
    maxRetryInterval: number;
    fetch: $Fetch;
    timeoutDurationMs: number | undefined;
    timeout: any;
    constructor(url: string, options?: EventSourcePlusOptions);
    private _handleRetry;
    private _handleConnection;
    listen(hooks: EventSourceHooks): EventSourceController;
}
type EventSourcePlusAbortEvent = {
    /**
     * "manual" - controller.abort() was manually called by the user
     *
     * "end-of-stream" - request was aborted because the stream from the server is ended ("on-error" retry strategy only)
     *
     * "error" - request was aborted because of an error
     */
    type: "manual" | "end-of-stream" | "error";
    reason?: string;
};
declare class EventSourceController {
    didAbort: boolean;
    /**
     * Do not modify. For internal use.
     */
    _abortController: AbortController;
    private _connect?;
    constructor(controller?: AbortController, connect?: (hooks?: EventSourceHooks) => Promise<void> | void);
    abort(reason?: string): void;
    reconnect(hooks?: EventSourceHooks): void;
    private _abortHook?;
    _emitEvent(e: EventSourcePlusAbortEvent): void;
    onAbort(fn: (event: EventSourcePlusAbortEvent) => any): void;
    get signal(): AbortSignal;
}
type HeaderMap = Record<string, string | undefined>;
interface EventSourcePlusOptions extends Omit<RequestInit, "method" | "headers"> {
    /**
     * The request http method
     *
     * (Default is `"get"`)
     */
    method?: HttpMethod;
    /**
     * Headers to be included in the http request, or a function returning headers.
     */
    headers?: HeaderMap | (() => HeaderMap | Promise<HeaderMap>);
    /**
     * Custom fetch implementation if you want to override
     */
    fetch?: Fetch;
    /**
     * Max number of times EventSourcePlus will attempt to retry connecting. Will retry indefinitely when set to `undefined`. The retry count gets reset after successfully connecting.
     *
     * (Default is `undefined`)
     */
    maxRetryCount?: number;
    /**
     * Max retry wait time in MS.
     *
     * Exponential backend will keep increasing the wait interval until this is reached.
     *
     * (Default is 30000)
     */
    maxRetryInterval?: number;
    /**
     * @beta
     * Set the client retry strategy.
     *
     * - `always` - The client will always attempt to reopen the connection after it has been closed. Recommended for realtime applications. (Default)
     * - `on-error` - The client will only attempt to reconnect if it received an error response. Useful for short lived text streams.
     *
     * @default "always"
     */
    retryStrategy?: "always" | "on-error";
    /**
     * Set a duration in milliseconds to expect the server to start sending a response
     */
    timeout?: number;
}
declare const HTTP_METHOD_VALS: readonly ["get", "head", "post", "put", "delete", "connect", "options", "trace", "patch"];
type HttpMethod = (typeof HTTP_METHOD_VALS)[number];
interface EventSourceHooks {
    /**
     * Fires every time a new message is received
     */
    onMessage: (message: SseMessage) => any;
    /**
     * Fires when a new request has been created.
     */
    onRequest?: (context: OnRequestContext) => any;
    /**
     * Fires when a there was an error sending a request
     */
    onRequestError?: (context: OnRequestErrorContext) => any;
    /**
     * Fires when receiving a response from the server
     */
    onResponse?: (context: OnResponseContext) => any;
    /**
     * Fires when the server has returned an error status code or the server doesn't return the expected content-type ("text/event-stream")
     */
    onResponseError?: (context: OnResponseErrorContext) => any;
}
type OnRequestContext = FetchContext<unknown>;
type OnRequestErrorContext = FetchContext<unknown> & {
    error: Error;
};
type OnResponseContext = FetchContext<unknown> & {
    response: FetchResponse<any>;
};
type OnResponseErrorContext = FetchContext<any> & {
    response: FetchResponse<any>;
};
declare function _handleResponse(context: OnResponseContext, hooks: EventSourceHooks): Promise<void>;

export { EventSourceController, EventSourcePlus, EventStreamContentType, HTTP_METHOD_VALS, _handleResponse, getBytes, messageListFromString, parseLine };
export type { EventSourceHooks, EventSourcePlusAbortEvent, EventSourcePlusOptions, HttpMethod, OnRequestContext, OnRequestErrorContext, OnResponseContext, OnResponseErrorContext, SseMessage };
