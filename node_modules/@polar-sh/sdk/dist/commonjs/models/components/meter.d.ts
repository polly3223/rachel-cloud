import * as z from "zod/v4-mini";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";
import { CountAggregation, CountAggregation$Outbound } from "./countaggregation.js";
import { Filter, Filter$Outbound } from "./filter.js";
import { MetadataOutputType, MetadataOutputType$Outbound } from "./metadataoutputtype.js";
import { PropertyAggregation, PropertyAggregation$Outbound } from "./propertyaggregation.js";
import { UniqueAggregation, UniqueAggregation$Outbound } from "./uniqueaggregation.js";
/**
 * The aggregation to apply on the filtered events to calculate the meter.
 */
export type MeterAggregation = (PropertyAggregation & {
    func: "avg";
}) | CountAggregation | (PropertyAggregation & {
    func: "max";
}) | (PropertyAggregation & {
    func: "min";
}) | (PropertyAggregation & {
    func: "sum";
}) | UniqueAggregation;
export type Meter = {
    metadata: {
        [k: string]: MetadataOutputType;
    };
    /**
     * Creation timestamp of the object.
     */
    createdAt: Date;
    /**
     * Last modification timestamp of the object.
     */
    modifiedAt: Date | null;
    /**
     * The ID of the object.
     */
    id: string;
    /**
     * The name of the meter. Will be shown on customer's invoices and usage.
     */
    name: string;
    filter: Filter;
    /**
     * The aggregation to apply on the filtered events to calculate the meter.
     */
    aggregation: (PropertyAggregation & {
        func: "avg";
    }) | CountAggregation | (PropertyAggregation & {
        func: "max";
    }) | (PropertyAggregation & {
        func: "min";
    }) | (PropertyAggregation & {
        func: "sum";
    }) | UniqueAggregation;
    /**
     * The ID of the organization owning the meter.
     */
    organizationId: string;
    /**
     * Whether the meter is archived and the time it was archived.
     */
    archivedAt?: Date | null | undefined;
};
/** @internal */
export declare const MeterAggregation$inboundSchema: z.ZodMiniType<MeterAggregation, unknown>;
/** @internal */
export type MeterAggregation$Outbound = (PropertyAggregation$Outbound & {
    func: "avg";
}) | CountAggregation$Outbound | (PropertyAggregation$Outbound & {
    func: "max";
}) | (PropertyAggregation$Outbound & {
    func: "min";
}) | (PropertyAggregation$Outbound & {
    func: "sum";
}) | UniqueAggregation$Outbound;
/** @internal */
export declare const MeterAggregation$outboundSchema: z.ZodMiniType<MeterAggregation$Outbound, MeterAggregation>;
export declare function meterAggregationToJSON(meterAggregation: MeterAggregation): string;
export declare function meterAggregationFromJSON(jsonString: string): SafeParseResult<MeterAggregation, SDKValidationError>;
/** @internal */
export declare const Meter$inboundSchema: z.ZodMiniType<Meter, unknown>;
/** @internal */
export type Meter$Outbound = {
    metadata: {
        [k: string]: MetadataOutputType$Outbound;
    };
    created_at: string;
    modified_at: string | null;
    id: string;
    name: string;
    filter: Filter$Outbound;
    aggregation: (PropertyAggregation$Outbound & {
        func: "avg";
    }) | CountAggregation$Outbound | (PropertyAggregation$Outbound & {
        func: "max";
    }) | (PropertyAggregation$Outbound & {
        func: "min";
    }) | (PropertyAggregation$Outbound & {
        func: "sum";
    }) | UniqueAggregation$Outbound;
    organization_id: string;
    archived_at?: string | null | undefined;
};
/** @internal */
export declare const Meter$outboundSchema: z.ZodMiniType<Meter$Outbound, Meter>;
export declare function meterToJSON(meter: Meter): string;
export declare function meterFromJSON(jsonString: string): SafeParseResult<Meter, SDKValidationError>;
//# sourceMappingURL=meter.d.ts.map