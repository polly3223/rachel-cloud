/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */
import * as z from "zod/v4-mini";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
/** @internal */
export const LLMMetadata$inboundSchema = z
    .pipe(z.object({
    vendor: z.string(),
    model: z.string(),
    prompt: z.optional(z.nullable(z.string())),
    response: z.optional(z.nullable(z.string())),
    input_tokens: z.int(),
    cached_input_tokens: z.optional(z.int()),
    output_tokens: z.int(),
    total_tokens: z.int(),
}), z.transform((v) => {
    return remap$(v, {
        "input_tokens": "inputTokens",
        "cached_input_tokens": "cachedInputTokens",
        "output_tokens": "outputTokens",
        "total_tokens": "totalTokens",
    });
}));
/** @internal */
export const LLMMetadata$outboundSchema = z.pipe(z.object({
    vendor: z.string(),
    model: z.string(),
    prompt: z.optional(z.nullable(z.string())),
    response: z.optional(z.nullable(z.string())),
    inputTokens: z.int(),
    cachedInputTokens: z.optional(z.int()),
    outputTokens: z.int(),
    totalTokens: z.int(),
}), z.transform((v) => {
    return remap$(v, {
        inputTokens: "input_tokens",
        cachedInputTokens: "cached_input_tokens",
        outputTokens: "output_tokens",
        totalTokens: "total_tokens",
    });
}));
export function llmMetadataToJSON(llmMetadata) {
    return JSON.stringify(LLMMetadata$outboundSchema.parse(llmMetadata));
}
export function llmMetadataFromJSON(jsonString) {
    return safeParse(jsonString, (x) => LLMMetadata$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'LLMMetadata' from JSON`);
}
//# sourceMappingURL=llmmetadata.js.map