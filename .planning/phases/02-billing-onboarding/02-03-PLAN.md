---
phase: 02-billing-onboarding
plan: 03
type: execute
wave: 2
depends_on: [02-01]
files_modified:
  - src/lib/onboarding/telegram-validator.ts
  - src/routes/api/onboarding/validate-bot/+server.ts
  - src/routes/onboarding/+page.svelte
  - src/routes/onboarding/+page.server.ts
autonomous: true

must_haves:
  truths:
    - "User can enter Telegram bot token in onboarding UI"
    - "System validates token via Telegram getMe API before accepting"
    - "Invalid tokens show clear error message"
    - "Valid tokens are stored encrypted in database"
    - "UI shows step-by-step BotFather instructions"
  artifacts:
    - path: "src/lib/onboarding/telegram-validator.ts"
      provides: "Telegram Bot API token validation"
      exports: ["validateTelegramBotToken"]
    - path: "src/routes/api/onboarding/validate-bot/+server.ts"
      provides: "API endpoint for bot token validation"
      exports: ["POST"]
    - path: "src/routes/onboarding/+page.svelte"
      provides: "Multi-step onboarding UI with progress tracking"
      min_lines: 50
    - path: "src/routes/onboarding/+page.server.ts"
      provides: "Server-side onboarding state loading"
      exports: ["load"]
  key_links:
    - from: "src/routes/onboarding/+page.svelte"
      to: "/api/onboarding/validate-bot"
      via: "fetch POST on form submit"
      pattern: "fetch.*validate-bot.*POST"
    - from: "src/routes/api/onboarding/validate-bot/+server.ts"
      to: "src/lib/onboarding/telegram-validator.ts"
      via: "calls validateTelegramBotToken"
      pattern: "validateTelegramBotToken"
    - from: "src/routes/api/onboarding/validate-bot/+server.ts"
      to: "telegramBots table"
      via: "stores encrypted token on success"
      pattern: "db\\.insert\\(telegramBots\\)"
---

<objective>
Implement Telegram bot token validation and multi-step onboarding UI guiding users through payment, bot setup, and VPS provisioning.

Purpose: Enable users to securely enter their Telegram bot token with validation, and guide them through the complete onboarding flow with clear instructions. This ensures users can complete setup in under 5 minutes (ONBR-04) with step-by-step guidance (ONBR-03).

Output: Telegram bot token validator using getMe API, onboarding UI with BotFather instructions, validated and encrypted token storage, and progress tracking through onboarding steps.
</objective>

<execution_context>
@/home/rachel/.claude/get-shit-done/workflows/execute-plan.md
@/home/rachel/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-billing-onboarding/02-CONTEXT.md
@.planning/phases/02-billing-onboarding/02-RESEARCH.md
@/tmp/rachel-cloud/src/lib/db/schema.ts
@/tmp/rachel-cloud/src/lib/crypto/encryption.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement Telegram bot token validator using getMe API</name>
  <files>
    src/lib/onboarding/telegram-validator.ts
  </files>
  <action>
Create `src/lib/onboarding/telegram-validator.ts` following RESEARCH.md Architecture Pattern 2:

1. Define TypeScript interfaces from Telegram Bot API:
   ```typescript
   interface TelegramUser {
     id: number;
     is_bot: boolean;
     first_name: string;
     username?: string;
   }

   interface TelegramResponse {
     ok: boolean;
     result?: TelegramUser;
     description?: string;
     error_code?: number;
   }
   ```

2. Implement `validateTelegramBotToken(token: string)` function:
   - Parameters: token (string)
   - Returns: Promise<{ valid: boolean; botUsername?: string; error?: string }>
   - Implementation:
     a. Make GET request to `https://api.telegram.org/bot${token}/getMe`
     b. Set 10-second timeout using AbortSignal.timeout(10000)
     c. Parse JSON response as TelegramResponse
     d. Validate response:
        - If !data.ok: return { valid: false, error: data.description || 'Invalid token' }
        - If !data.result?.is_bot: return { valid: false, error: 'Token does not belong to a bot' }
        - If valid: return { valid: true, botUsername: data.result.username }
     e. Catch network errors: return { valid: false, error: 'Failed to validate token. Please check your connection.' }

3. Add retry logic from RESEARCH.md Pitfall 4:
   - Implement 3 retry attempts with exponential backoff
   - Retry only on network errors (timeout, 5xx), not on 4xx (invalid token)
   - Distinguish between "invalid token" (400 from Telegram) and "network failure" (timeout/5xx)

Include comprehensive error handling per RESEARCH.md Common Pitfalls section.
  </action>
  <verify>
Verify TypeScript compilation:
```bash
cd /tmp/rachel-cloud && bun run check
```

Test validator function with mock token:
```bash
cd /tmp/rachel-cloud && bun -e "
import { validateTelegramBotToken } from './src/lib/onboarding/telegram-validator.ts';
const result = await validateTelegramBotToken('invalid-token-test');
console.log('Validation result:', result);
console.log('✓ Validator returns error for invalid token');
"
```
  </verify>
  <done>
Telegram bot token validator implemented using getMe API endpoint. Validator distinguishes between invalid tokens and network failures. Retry logic with exponential backoff handles transient network issues. Returns clear error messages for user feedback.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create bot validation API endpoint with encrypted storage</name>
  <files>
    src/routes/api/onboarding/validate-bot/+server.ts
  </files>
  <action>
Create `src/routes/api/onboarding/validate-bot/+server.ts`:

1. Import dependencies:
   - validateTelegramBotToken from '$lib/onboarding/telegram-validator'
   - encryptToken from '$lib/crypto/encryption'
   - db, telegramBots from '$lib/db'
   - crypto.randomUUID for ID generation

2. Implement POST handler:
   a. Get session from event.locals.session (Better Auth)
   b. If no session, return { status: 401, body: { error: 'Unauthorized' } }
   c. Parse request body: { token: string }
   d. Validate token is non-empty string
   e. Call validateTelegramBotToken(token)
   f. If validation fails, return { status: 400, body: { error: validation.error } }
   g. If validation succeeds:
      - Encrypt token using encryptToken() (reuse Phase 1 encryption pattern)
      - Insert into telegramBots table:
        - id: crypto.randomUUID()
        - userId: session.userId
        - botUsername: validation.botUsername
        - encryptedToken: encrypted token
        - validated: true
        - createdAt, updatedAt: new Date()
      - Use onConflictDoUpdate to handle existing bot token (userId is unique)
   h. Return { status: 200, body: { success: true, botUsername: validation.botUsername } }
   i. Wrap in try/catch, return 500 on unexpected errors

3. Add rate limiting comment (implementation deferred):
   ```typescript
   // TODO: Add rate limiting (max 5 validation attempts per hour per user)
   ```

Follow RESEARCH.md Pattern 2 for token validation and CONTEXT.md LOCKED decision: encrypt tokens using existing AES-256-GCM pattern from Phase 1.
  </action>
  <verify>
Verify TypeScript compilation:
```bash
cd /tmp/rachel-cloud && bun run check
```

Verify endpoint file exists and exports POST:
```bash
cd /tmp/rachel-cloud && bun -e "
const module = await import('./src/routes/api/onboarding/validate-bot/+server.ts');
console.log('Exports:', Object.keys(module));
console.log('✓ POST handler exported');
"
```
  </verify>
  <done>
Bot validation endpoint accepts token via POST, validates using Telegram API, encrypts and stores valid tokens in database. Session authentication ensures only logged-in users can validate. Error responses distinguish between validation failures and server errors.
  </done>
</task>

<task type="auto">
  <name>Task 3: Build multi-step onboarding UI with BotFather instructions</name>
  <files>
    src/routes/onboarding/+page.svelte
    src/routes/onboarding/+page.server.ts
  </files>
  <action>
Create `src/routes/onboarding/+page.server.ts` to load onboarding state:
1. Import db, subscriptions, telegramBots from '$lib/db'
2. Import eq from 'drizzle-orm'
3. Implement load function:
   - Get session from event.locals.session
   - If no session, redirect to /auth/login
   - Query subscription status from database
   - Query telegram bot status from database
   - Calculate current step:
     - If no active subscription: step = 'payment'
     - Else if no telegram bot configured: step = 'telegram_bot'
     - Else: step = 'provisioning' (Phase 3)
   - Return: { step, subscription, hasBot }

Create `src/routes/onboarding/+page.svelte` with multi-step UI following RESEARCH.md Architecture Pattern 5:

1. Import data from $page.data (SvelteKit pattern)
2. Define step enum: 'payment' | 'telegram_bot' | 'provisioning'
3. State management:
   - currentStep: from data.step
   - botToken: string (user input)
   - validating: boolean (loading state)
   - error: string | null
   - botUsername: string | null (validated result)

4. Payment step UI:
   - Heading: "Subscribe to Rachel Cloud"
   - Pricing: "$20/month - Single plan"
   - Button: "Subscribe Now" (calls authClient.checkout({ slug: "rachel-cloud-monthly" }))
   - Import authClient from Better Auth client setup (create src/lib/auth/client.ts if needed)

5. Telegram bot step UI:
   - Progress indicator: "Step 2 of 3: Connect Your Telegram Bot"
   - BotFather instructions (ONBR-03):
     - "Open Telegram and search for @BotFather"
     - "Send /newbot and follow the prompts"
     - "Choose a name and username for your bot"
     - "Copy the API token BotFather provides"
     - "Paste the token below"
   - Form:
     - Text input for bot token (masked password input)
     - "Validate & Continue" button
     - Error display area
     - Success message with bot username
   - On submit:
     - Set validating = true
     - POST to /api/onboarding/validate-bot with token
     - On success: Show success, advance to next step
     - On error: Display error message
     - Set validating = false

6. Provisioning step placeholder:
   - Heading: "Deploying Your Rachel Instance"
   - Message: "Phase 3: VPS provisioning will happen here"
   - Loading spinner or progress indicator

7. Styling:
   - Use Tailwind classes via CDN (Phase 1 pattern)
   - Card layout, centered content
   - Clear typography hierarchy
   - Mobile-responsive design
   - Progress bar at top showing 33% / 66% / 100%

Target completion time: Under 5 minutes per ONBR-04 requirement.
  </action>
  <verify>
Verify TypeScript compilation:
```bash
cd /tmp/rachel-cloud && bun run check
```

Start dev server and check onboarding page loads:
```bash
cd /tmp/rachel-cloud && timeout 5 bun run dev &
sleep 3
curl -I http://localhost:5173/onboarding 2>&1 | grep -q "200" && echo "✓ Onboarding page accessible"
pkill -f "vite dev"
```
  </verify>
  <done>
Multi-step onboarding UI guides users through payment, Telegram bot setup, and provisioning. BotFather instructions are clear and step-by-step. Progress indicator shows completion status. Bot token validation provides immediate feedback. UI is responsive and targets sub-5-minute completion.
  </done>
</task>

</tasks>

<verification>
1. Run `bun run check` and verify TypeScript compilation with no errors
2. Test telegram-validator.ts with invalid token and verify error message
3. Verify validate-bot endpoint requires authentication (401 without session)
4. Verify onboarding page loads and shows correct step based on user state
5. Verify BotFather instructions are clear and actionable
6. Verify form submission calls validation endpoint and handles errors
</verification>

<success_criteria>
1. User can enter Telegram bot token and receive validation feedback within 2 seconds
2. Invalid tokens display clear error messages (invalid vs network failure)
3. Valid tokens are encrypted using AES-256-GCM and stored in database
4. BotFather instructions guide user through bot creation in under 3 minutes
5. Onboarding UI shows progress (payment → bot → provisioning)
6. Page is mobile-responsive and accessible
7. Session authentication prevents unauthorized access to onboarding
</success_criteria>

<output>
After completion, create `.planning/phases/02-billing-onboarding/02-03-SUMMARY.md` using the summary template.
</output>
