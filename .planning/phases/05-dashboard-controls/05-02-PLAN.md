---
phase: 05-dashboard-controls
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/provisioning/ssh-exec.ts
  - src/lib/provisioning/vps-status.ts
  - src/routes/api/vps/status/+server.ts
  - src/routes/api/vps/restart/+server.ts
  - src/routes/api/vps/logs/+server.ts
autonomous: true

must_haves:
  truths:
    - "System can check VPS status (running/off/error) via Hetzner API for a given user"
    - "System can restart the rachel8 service on a user's VPS via SSH"
    - "System can fetch recent log lines from a user's VPS via SSH"
    - "All VPS operations require authenticated session and active subscription"
  artifacts:
    - path: "src/lib/provisioning/ssh-exec.ts"
      provides: "Reusable SSH command executor"
      exports: ["execSSHCommand"]
    - path: "src/lib/provisioning/vps-status.ts"
      provides: "VPS status checking and service management"
      exports: ["getVPSStatus", "restartRachelService", "fetchServiceLogs", "getServiceUptime"]
    - path: "src/routes/api/vps/status/+server.ts"
      provides: "GET endpoint for VPS status"
      exports: ["GET"]
    - path: "src/routes/api/vps/restart/+server.ts"
      provides: "POST endpoint for service restart"
      exports: ["POST"]
    - path: "src/routes/api/vps/logs/+server.ts"
      provides: "GET endpoint for service logs"
      exports: ["GET"]
  key_links:
    - from: "src/lib/provisioning/vps-status.ts"
      to: "src/lib/provisioning/ssh-exec.ts"
      via: "import execSSHCommand"
      pattern: "execSSHCommand"
    - from: "src/lib/provisioning/vps-status.ts"
      to: "src/lib/provisioning/hetzner-client.ts"
      via: "import HetznerClient"
      pattern: "HetznerClient"
    - from: "src/routes/api/vps/restart/+server.ts"
      to: "src/lib/provisioning/vps-status.ts"
      via: "import restartRachelService"
      pattern: "restartRachelService"
---

<objective>
Create reusable SSH command execution utility and VPS management functions with API endpoints.

Purpose: Build the backend infrastructure for user dashboard features (status checking, service restart, log viewing). These utilities are also reused by the admin dashboard in Plan 04.

Output: SSH exec utility, VPS status/restart/logs functions, three API endpoints.
</objective>

<execution_context>
@/home/rachel/.claude/get-shit-done/workflows/execute-plan.md
@/home/rachel/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-dashboard-controls/05-RESEARCH.md
@src/lib/provisioning/ssh-injector.ts
@src/lib/provisioning/hetzner-client.ts
@src/lib/provisioning/types.ts
@src/lib/auth/session.ts
@src/lib/billing/subscription-manager.ts
@src/lib/crypto/encryption.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create reusable SSH command executor and VPS management functions</name>
  <files>src/lib/provisioning/ssh-exec.ts, src/lib/provisioning/vps-status.ts</files>
  <action>
    Create `src/lib/provisioning/ssh-exec.ts`:
    - Extract the SSH connection and command execution pattern from `ssh-injector.ts` into a generic, reusable function
    - Export `execSSHCommand(config: SSHExecConfig): Promise<SSHExecResult>` where:
      - `SSHExecConfig` has: `host: string`, `privateKey: string`, `command: string`, `username?: string` (default 'rachel'), `connectTimeoutMs?: number` (default 15000), `commandTimeoutMs?: number` (default 15000)
      - `SSHExecResult` has: `stdout: string`, `stderr: string`, `exitCode: number`
    - Implementation: Create ssh2 `Client`, connect with timeout, exec command, collect stdout/stderr, return result. ALWAYS close connection in finally block.
    - Use shorter timeouts than ssh-injector (15s vs 30s) because these are quick status checks, not provisioning operations
    - Handle connection errors gracefully: catch and wrap in descriptive error messages

    Create `src/lib/provisioning/vps-status.ts`:
    - Import `HetznerClient` from `./hetzner-client`
    - Import `execSSHCommand` from `./ssh-exec`
    - Import `decryptToken` from `$lib/crypto/encryption`

    Export functions:

    1. `getVPSStatus(hetznerServerId: number): Promise<VPSStatus>` where VPSStatus has `{ status: string, ip: string, created: string, datacenter: string }`. Uses `HetznerClient.getServer()`. Create HetznerClient with `process.env.HETZNER_API_TOKEN`. Wrap in try/catch, return `{ status: 'unknown', ... }` on error.

    2. `restartRachelService(host: string, encryptedPrivateKey: string): Promise<{ success: boolean, message: string }>`:
      - Decrypt private key using `decryptToken()`
      - Execute `sudo systemctl restart rachel8` via SSH
      - Wait 2 seconds, then check status with `sudo systemctl is-active rachel8`
      - Return `{ success: true, message: 'Service restarted' }` if active, or `{ success: false, message: <error> }` on failure
      - Catch SSH errors and return `{ success: false, message: 'Failed to connect to VPS' }`

    3. `fetchServiceLogs(host: string, encryptedPrivateKey: string, lines?: number): Promise<{ logs: string, success: boolean }>`:
      - Default `lines` to 100
      - Decrypt private key
      - Execute `journalctl -u rachel8 -n ${lines} --no-pager` via SSH
      - Return `{ logs: stdout, success: true }`
      - On error return `{ logs: '', success: false }`

    4. `getServiceUptime(host: string, encryptedPrivateKey: string): Promise<{ uptime: string, success: boolean }>`:
      - Decrypt private key
      - Execute `uptime -p` via SSH (gives human-readable uptime like "up 3 days, 2 hours")
      - Return `{ uptime: stdout, success: true }`
      - On error return `{ uptime: 'Unknown', success: false }`

    Define `VPSStatus` type in this file (not in types.ts, keep it local to this module).
  </action>
  <verify>
    - `src/lib/provisioning/ssh-exec.ts` exists with `execSSHCommand` export
    - `src/lib/provisioning/vps-status.ts` exists with all 4 function exports
    - TypeScript types are correct: `npx svelte-check --tsconfig ./tsconfig.json 2>&1 | grep -i 'error' | head -10`
  </verify>
  <done>Reusable SSH executor created. VPS management functions (getVPSStatus, restartRachelService, fetchServiceLogs, getServiceUptime) implemented using existing HetznerClient and ssh2 patterns.</done>
</task>

<task type="auto">
  <name>Task 2: Create API endpoints for VPS status, restart, and logs</name>
  <files>src/routes/api/vps/status/+server.ts, src/routes/api/vps/restart/+server.ts, src/routes/api/vps/logs/+server.ts</files>
  <action>
    Create three SvelteKit API endpoints under `src/routes/api/vps/`:

    **`src/routes/api/vps/status/+server.ts`** (GET):
    - Import `requireAuth` from `$lib/auth/session`
    - Import `getSubscription` from `$lib/billing/subscription-manager`
    - Import `getVPSStatus`, `getServiceUptime` from `$lib/provisioning/vps-status`
    - Get session via `requireAuth(event)`, get subscription via `getSubscription(session.user.id)`
    - Validate: subscription exists, `vpsProvisioned` is true, `hetznerServerId` exists
    - If not provisioned, return `json({ status: 'not_provisioned' })`
    - Call `getVPSStatus(subscription.hetznerServerId)` for Hetzner status
    - If Hetzner status is 'running', also call `getServiceUptime()` using `subscription.vpsIpAddress` and `subscription.sshPrivateKey`
    - Return `json({ status: hetznerStatus.status, ip: hetznerStatus.ip, datacenter: hetznerStatus.datacenter, uptime: uptimeResult.uptime, created: hetznerStatus.created })`
    - Wrap in try/catch, return 500 on unexpected errors

    **`src/routes/api/vps/restart/+server.ts`** (POST):
    - Same auth/subscription checks as status
    - Validate VPS is provisioned and has IP address and SSH private key
    - Call `restartRachelService(subscription.vpsIpAddress, subscription.sshPrivateKey)`
    - Return `json({ success: result.success, message: result.message })`
    - On error return `json({ success: false, message: 'Failed to restart service' }, { status: 500 })`

    **`src/routes/api/vps/logs/+server.ts`** (GET):
    - Same auth/subscription checks
    - Read `lines` query parameter from URL (default 100, max 500): `const lines = Math.min(parseInt(event.url.searchParams.get('lines') || '100'), 500)`
    - Call `fetchServiceLogs(subscription.vpsIpAddress, subscription.sshPrivateKey, lines)`
    - Return `json({ logs: result.logs, success: result.success })`
    - On error return `json({ logs: '', success: false, message: 'Failed to fetch logs' }, { status: 500 })`

    All endpoints must:
    - Use `requireAuth` (not just getSession) to ensure authenticated
    - Return proper HTTP status codes (200 for success, 401 for unauth, 403 for no subscription, 500 for server error)
    - Include `Content-Type: application/json` (automatic with SvelteKit json())
  </action>
  <verify>
    - All three endpoint files exist under `src/routes/api/vps/`
    - Each endpoint imports from the correct utility modules
    - Each endpoint calls `requireAuth` for authentication
    - Build passes: `cd /tmp/rachel-cloud && npx vite build 2>&1 | tail -10`
  </verify>
  <done>Three API endpoints created: GET /api/vps/status, POST /api/vps/restart, GET /api/vps/logs. All require authentication and active subscription. Status endpoint combines Hetzner API status with SSH uptime check.</done>
</task>

</tasks>

<verification>
1. `src/lib/provisioning/ssh-exec.ts` provides reusable SSH command execution with timeout handling
2. `src/lib/provisioning/vps-status.ts` provides getVPSStatus, restartRachelService, fetchServiceLogs, getServiceUptime
3. GET `/api/vps/status` returns server status for authenticated user with provisioned VPS
4. POST `/api/vps/restart` restarts rachel8 service via SSH for authenticated user
5. GET `/api/vps/logs` returns recent log lines via SSH for authenticated user
6. All API endpoints require authentication and handle errors gracefully
</verification>

<success_criteria>
- SSH command executor works with existing ssh2 library patterns
- VPS status retrieval uses existing HetznerClient.getServer() method
- Service restart sends correct systemctl command via SSH
- Log fetching retrieves journalctl output via SSH
- API endpoints enforce authentication and subscription checks
- Error cases return informative error messages (not raw stack traces)
</success_criteria>

<output>
After completion, create `.planning/phases/05-dashboard-controls/05-02-SUMMARY.md`
</output>
