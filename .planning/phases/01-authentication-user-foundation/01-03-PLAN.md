---
phase: 01-authentication-user-foundation
plan: 03
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/auth/providers/claude.ts
  - src/routes/claude-oauth.ts
  - src/db/schema.ts
  - src/auth/token-refresh.ts
autonomous: true
user_setup:
  - service: claude-oauth
    why: "Claude OAuth for connecting user's Claude accounts"
    env_vars:
      - name: CLAUDE_CLIENT_ID
        source: "Anthropic Developer Console (when available) or use public client ID from grll/claude-code-login reference"
      - name: CLAUDE_REDIRECT_URI
        source: "Set to http://localhost:3000/api/claude/callback for development"
    dashboard_config:
      - task: "Register OAuth application (when Anthropic provides self-service registration)"
        location: "Anthropic Developer Console or use existing public client ID for testing"

must_haves:
  truths:
    - "Users can initiate Claude OAuth flow and receive authorization URL with PKCE"
    - "Users complete OAuth and tokens are encrypted before database storage"
    - "Claude access tokens are automatically refreshed before expiration"
    - "Users can disconnect their Claude account"
  artifacts:
    - path: "src/auth/providers/claude.ts"
      provides: "Claude OAuth 2.0 + PKCE implementation"
      exports: ["startClaudeOAuthFlow", "exchangeClaudeCode"]
      min_lines: 80
    - path: "src/routes/claude-oauth.ts"
      provides: "Hono routes for Claude OAuth flow"
      exports: ["claudeOAuthRouter"]
      min_lines: 100
    - path: "src/auth/token-refresh.ts"
      provides: "Proactive token refresh logic"
      exports: ["ensureValidToken", "refreshClaudeToken"]
      min_lines: 60
    - path: "src/db/schema.ts"
      provides: "OAuth state table for PKCE flow"
      contains: "oauthStates.*pgTable"
  key_links:
    - from: "src/routes/claude-oauth.ts"
      to: "src/auth/providers/claude.ts"
      via: "Call startClaudeOAuthFlow and exchangeClaudeCode"
      pattern: "startClaudeOAuthFlow.*exchangeClaudeCode"
    - from: "src/routes/claude-oauth.ts"
      to: "src/auth/encryption.ts"
      via: "Encrypt tokens before storing in accounts table"
      pattern: "encryption\\.encrypt.*accessToken"
    - from: "src/auth/token-refresh.ts"
      to: "src/auth/encryption.ts"
      via: "Decrypt tokens for refresh, re-encrypt after refresh"
      pattern: "encryption\\.decrypt.*encryption\\.encrypt"
---

<objective>
Implement Claude OAuth 2.0 + PKCE authentication flow with encrypted token storage and proactive token refresh.

Purpose: Enable users to securely connect their Claude accounts to Rachel Cloud; store Claude OAuth tokens encrypted at rest; automatically refresh tokens before expiration to prevent service disruption.

Output: Claude OAuth endpoints, PKCE implementation, encrypted token storage, and automatic token refresh system.
</objective>

<execution_context>
@/home/rachel/.claude/get-shit-done/workflows/execute-plan.md
@/home/rachel/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/REQUIREMENTS.md
@.planning/phases/01-authentication-user-foundation/01-RESEARCH.md
@.planning/phases/01-authentication-user-foundation/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Add OAuth state table for PKCE flow</name>
  <files>
src/db/schema.ts
  </files>
  <action>
Add oauthStates table to existing schema for storing PKCE verifiers during OAuth flow:

**oauthStates table:**
- state: text (primary key, cryptographically random state parameter)
- codeVerifier: text (not null, PKCE code_verifier to be used during token exchange)
- userId: text (not null, foreign key to users.id—the user initiating OAuth)
- createdAt: timestamp (default now, not null)
- expiresAt: timestamp (not null, state expires after 10 minutes to prevent replay attacks)

Use pgTable from drizzle-orm/pg-core.
Add foreign key reference: references(() => users.id)
Export oauthStates table.

**After schema change:**
Run migration to apply: `bun run drizzle-kit push`

Why needed: PKCE requires storing code_verifier server-side between authorization request (step 1) and token exchange (step 2). The state parameter links authorization callback to original code_verifier.
  </action>
  <verify>
```bash
cd /tmp/rachel-cloud && bun run drizzle-kit push
cd /tmp/rachel-cloud && node -e "
const { oauthStates } = require('./src/db/schema.ts');
console.assert(oauthStates !== undefined, 'oauthStates table not exported');
console.log('✓ OAuth state table added');
"
```
Migration succeeds, table exports successfully
  </verify>
  <done>
OAuth state table added to schema; supports PKCE flow by storing code_verifier linked to state parameter
  </done>
</task>

<task type="auto">
  <name>Implement Claude OAuth 2.0 + PKCE provider</name>
  <files>
src/auth/providers/claude.ts
  </files>
  <action>
Create Claude OAuth implementation with PKCE support:

**Import dependencies:**
- Import pkceChallenge from "pkce-challenge"
- Import crypto from "node:crypto"

**ClaudeOAuthConfig interface:**
```typescript
interface ClaudeOAuthConfig {
  mode: "max" | "console"; // max = Claude subscription, console = API keys
  clientId: string;
  redirectUri: string;
}
```

**startClaudeOAuthFlow function:**
- Parameters: (config: ClaudeOAuthConfig)
- Generate PKCE challenge: const { code_verifier, code_challenge } = await pkceChallenge()
- Generate state: crypto.randomBytes(32).toString("base64url")
- Determine auth endpoint based on mode:
  - mode === "max": "https://claude.ai/oauth/authorize"
  - mode === "console": "https://console.anthropic.com/oauth/authorize"
- Build authorization URL with URLSearchParams:
  - client_id, redirect_uri, response_type: "code"
  - code_challenge, code_challenge_method: "S256"
  - state, scope: "openid profile email"
- Return: { authUrl, state, codeVerifier }

**exchangeClaudeCode function:**
- Parameters: (code: string, codeVerifier: string, config: ClaudeOAuthConfig)
- Determine token endpoint based on mode:
  - mode === "max": "https://claude.ai/oauth/token"
  - mode === "console": "https://console.anthropic.com/oauth/token"
- POST to token endpoint with URLSearchParams:
  - grant_type: "authorization_code"
  - code, redirect_uri, client_id, code_verifier
- Check response.ok, throw error if not 200
- Parse JSON response: { access_token, refresh_token, expires_in, token_type, scope }
- Return full response object

Export both functions.

Follow exact pattern from research (01-RESEARCH.md, "Pattern 3: Claude OAuth 2.0 + PKCE Implementation").
Use "max" mode by default (targets Claude subscription users, which is our audience).
  </action>
  <verify>
```bash
cd /tmp/rachel-cloud && node -e "
const { startClaudeOAuthFlow, exchangeClaudeCode } = require('./src/auth/providers/claude.ts');
const result = startClaudeOAuthFlow({
  mode: 'max',
  clientId: 'test_client',
  redirectUri: 'http://localhost:3000/callback'
});
result.then(r => {
  console.assert(r.authUrl.includes('claude.ai/oauth/authorize'), 'Auth URL incorrect');
  console.assert(r.state.length > 0, 'State not generated');
  console.assert(r.codeVerifier.length > 0, 'Code verifier not generated');
  console.log('✓ Claude OAuth provider implemented');
});
"
```
OAuth flow functions generate valid PKCE parameters and URLs
  </verify>
  <done>
Claude OAuth provider implemented with PKCE support; generates authorization URLs and exchanges codes for tokens
  </done>
</task>

<task type="auto">
  <name>Create Claude OAuth routes with encrypted token storage</name>
  <files>
src/routes/claude-oauth.ts
  </files>
  <action>
Create Hono router for Claude OAuth flow with encrypted token storage:

**Import dependencies:**
- Import Hono from "hono"
- Import startClaudeOAuthFlow, exchangeClaudeCode from "../auth/providers/claude"
- Import TokenEncryption from "../auth/encryption"
- Import db from "../db"
- Import oauthStates, accounts from "../db/schema"
- Import requireAuth from "../middleware/auth"
- Import eq from "drizzle-orm"

**Initialize encryption:**
- const encryption = new TokenEncryption()

**Route 1: GET /connect**
- Apply requireAuth middleware (user must be logged in)
- Get user from context: c.get("user")
- Call startClaudeOAuthFlow with config:
  - mode: "max"
  - clientId: process.env.CLAUDE_CLIENT_ID
  - redirectUri: process.env.CLAUDE_REDIRECT_URI
- Insert state into oauthStates table:
  - state, codeVerifier, userId: user.id
  - expiresAt: new Date(Date.now() + 10 * 60 * 1000) // 10 minutes
- Return: c.json({ authUrl })

**Route 2: GET /callback**
- Extract code and state from query params: c.req.query("code"), c.req.query("state")
- Validate code and state exist, return 400 if missing
- Query oauthStates table for state record:
  - SELECT * FROM oauthStates WHERE state = ? AND expiresAt > NOW()
  - If not found: return 400 { error: "Invalid or expired state" }
- Get codeVerifier and userId from state record
- Call exchangeClaudeCode with code, codeVerifier, config
- Encrypt tokens:
  - encryptedAccessToken = encryption.encrypt(response.access_token)
  - encryptedRefreshToken = encryption.encrypt(response.refresh_token)
- Calculate expiresAt: new Date(Date.now() + response.expires_in * 1000)
- Insert or update accounts table:
  - userId, providerId: "claude", accountId: userId (for now, use userId as placeholder)
  - accessToken: encryptedAccessToken, refreshToken: encryptedRefreshToken
  - expiresAt, scope: response.scope
  - Use INSERT ON CONFLICT (userId, providerId) DO UPDATE to handle reconnections
- Delete used state from oauthStates table
- Redirect to frontend success page: c.redirect(process.env.FRONTEND_URL + "/dashboard?claude=connected")

**Route 3: POST /disconnect**
- Apply requireAuth middleware
- Get user from context
- Delete from accounts table: WHERE userId = user.id AND providerId = "claude"
- Return: c.json({ success: true })

**Route 4: GET /status**
- Apply requireAuth middleware
- Get user from context
- Query accounts table: WHERE userId = user.id AND providerId = "claude"
- If found: return c.json({ connected: true, expiresAt: account.expiresAt })
- If not found: return c.json({ connected: false })

Create router, add all routes, export as claudeOAuthRouter.
  </action>
  <verify>
```bash
cd /tmp/rachel-cloud && node -e "
process.env.DATABASE_URL = 'postgresql://user:pass@localhost:5432/testdb';
process.env.ENCRYPTION_KEY = require('crypto').randomBytes(32).toString('hex');
process.env.CLAUDE_CLIENT_ID = 'test';
process.env.CLAUDE_REDIRECT_URI = 'http://localhost:3000/api/claude/callback';
const claudeOAuthRouter = require('./src/routes/claude-oauth.ts').default;
console.assert(claudeOAuthRouter !== undefined, 'Claude OAuth router not exported');
console.log('✓ Claude OAuth routes created');
"
```
Router exports successfully with all OAuth routes
  </verify>
  <done>
Claude OAuth routes created with encrypted token storage; users can connect, disconnect, and check Claude account status
  </done>
</task>

<task type="auto">
  <name>Implement proactive token refresh system</name>
  <files>
src/auth/token-refresh.ts
  </files>
  <action>
Create token refresh system to prevent expiration during long sessions:

**Import dependencies:**
- Import TokenEncryption from "./encryption"

**TokenData interface:**
```typescript
interface TokenData {
  accessToken: string;
  refreshToken: string;
  expiresAt: Date;
}
```

**ensureValidToken function:**
- Parameters: (tokenData: TokenData, refreshFn: (refreshToken: string) => Promise<TokenData>)
- Calculate buffer time: 5 * 60 * 1000 (refresh 5 minutes before expiry)
- Check if token expires soon: tokenData.expiresAt.getTime() - Date.now() < bufferTime
- If expiring soon:
  - console.log("Token expiring soon, refreshing...")
  - Call refreshFn(tokenData.refreshToken)
  - Return new token data
- Else: return existing tokenData

**refreshClaudeToken function:**
- Parameters: (refreshToken: string, mode: "max" | "console" = "max")
- Determine token endpoint based on mode:
  - mode === "max": "https://claude.ai/oauth/token"
  - mode === "console": "https://console.anthropic.com/oauth/token"
- POST with URLSearchParams:
  - grant_type: "refresh_token"
  - refresh_token: refreshToken
- Check response.ok, throw error if failed
- Parse response: { access_token, refresh_token, expires_in }
- Return:
  ```typescript
  {
    accessToken: data.access_token,
    refreshToken: data.refresh_token || refreshToken, // Some providers don't issue new refresh token
    expiresAt: new Date(Date.now() + data.expires_in * 1000)
  }
  ```

**getValidClaudeToken helper function:**
- Parameters: (userId: string, db: any, encryption: TokenEncryption)
- Query accounts table for user's Claude account
- If not found: throw error "Claude account not connected"
- Decrypt tokens:
  - accessToken = encryption.decrypt(account.accessToken)
  - refreshToken = encryption.decrypt(account.refreshToken)
- Call ensureValidToken with current token data and refreshClaudeToken as refreshFn
- If token was refreshed:
  - Encrypt new tokens
  - Update accounts table with new encrypted tokens and expiresAt
- Return decrypted access token (ready to use)

Export all functions.

Follow pattern from research (01-RESEARCH.md, "Pattern 4: Proactive Token Refresh").
Use 5-minute buffer based on research recommendation for Claude's 8-12 hour token lifetime.
  </action>
  <verify>
```bash
cd /tmp/rachel-cloud && node -e "
const { ensureValidToken, refreshClaudeToken, getValidClaudeToken } = require('./src/auth/token-refresh.ts');
console.assert(typeof ensureValidToken === 'function', 'ensureValidToken not exported');
console.assert(typeof refreshClaudeToken === 'function', 'refreshClaudeToken not exported');
console.assert(typeof getValidClaudeToken === 'function', 'getValidClaudeToken not exported');
console.log('✓ Token refresh system implemented');
"
```
All refresh functions export successfully
  </verify>
  <done>
Token refresh system implemented; automatically refreshes Claude tokens 5 minutes before expiration; provides helper to get always-valid tokens
  </done>
</task>

<task type="auto">
  <name>Mount Claude OAuth routes and update main app</name>
  <files>
src/index.ts
  </files>
  <action>
Update main application to mount Claude OAuth routes:

**Import claudeOAuthRouter:**
- Import claudeOAuthRouter from "./routes/claude-oauth"

**Mount router:**
- Add: app.route("/api/claude", claudeOAuthRouter)
- Place after existing auth routes

**Environment variable validation (add to startup):**
- Check CLAUDE_CLIENT_ID and CLAUDE_REDIRECT_URI exist
- If missing: console.warn("Claude OAuth not configured - set CLAUDE_CLIENT_ID and CLAUDE_REDIRECT_URI")
- App should still start but Claude OAuth won't work

No other changes needed—auth routes from 01-02 remain unchanged.
  </action>
  <verify>
```bash
cd /tmp/rachel-cloud && bun run src/index.ts &
sleep 2
curl -s http://localhost:3000/api/claude/status -H "Cookie: invalid" | grep -q "Unauthorized"
kill %1
```
Server starts, Claude OAuth endpoints respond (401 for unauthenticated)
  </verify>
  <done>
Claude OAuth routes mounted at /api/claude; environment validation warns if Claude OAuth not configured
  </done>
</task>

</tasks>

<verification>
1. Start server: `bun run src/index.ts`
2. Create test user: `curl -X POST http://localhost:3000/api/auth/signup -H "Content-Type: application/json" -d '{"email":"claude-test@example.com","password":"password123","name":"Claude Test"}' -c cookies.txt`
3. Login: `curl -X POST http://localhost:3000/api/auth/login -H "Content-Type: application/json" -d '{"email":"claude-test@example.com","password":"password123"}' -c cookies.txt`
4. Start Claude OAuth: `curl http://localhost:3000/api/claude/connect -b cookies.txt` returns authUrl with claude.ai/oauth/authorize
5. Check status (before connection): `curl http://localhost:3000/api/claude/status -b cookies.txt` returns { connected: false }
6. Verify database encryption: Query accounts table—accessToken and refreshToken should be encrypted (format: base64~base64~base64)
7. Test token refresh: Mock token expiring in 4 minutes, call getValidClaudeToken, verify it triggers refresh
</verification>

<success_criteria>
- Users can initiate Claude OAuth flow and receive PKCE-enabled authorization URL
- OAuth callback exchanges code for tokens and stores encrypted in database
- Tokens are encrypted with AES-256-GCM before storage (visible in database as encrypted format)
- Token refresh system automatically refreshes tokens before 5-minute expiration buffer
- Users can check connection status and disconnect Claude account
- Requirements AUTH-04 (Claude OAuth + PKCE), AUTH-05 (encrypted storage), and AUTH-06 (auto-refresh) are fully implemented
</success_criteria>

<output>
After completion, create `.planning/phases/01-authentication-user-foundation/01-03-SUMMARY.md` documenting:
- Claude OAuth flow architecture and PKCE implementation
- Token encryption format and key management
- Token refresh strategy and buffer timing
- Testing results with real or mocked Claude OAuth endpoints
- Any deviations from research or issues with Claude OAuth API
- Integration points for future provisioning system (how to get valid tokens)
</output>
