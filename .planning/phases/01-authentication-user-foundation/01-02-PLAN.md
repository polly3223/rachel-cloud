---
phase: 01-authentication-user-foundation
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/routes/auth.ts
  - src/middleware/auth.ts
  - src/middleware/rate-limit.ts
  - src/index.ts
autonomous: true

must_haves:
  truths:
    - "Users can sign up with email and password"
    - "Users can log in with email and password"
    - "Users can sign up/log in with Google OAuth"
    - "Sessions persist across requests using HTTP-only cookies"
    - "Auth endpoints are protected with rate limiting"
  artifacts:
    - path: "src/routes/auth.ts"
      provides: "Hono routes mounting Better Auth handler"
      exports: ["authRouter"]
      min_lines: 20
    - path: "src/middleware/auth.ts"
      provides: "Authentication middleware for protected routes"
      exports: ["requireAuth"]
      min_lines: 30
    - path: "src/middleware/rate-limit.ts"
      provides: "Rate limiting configuration for auth endpoints"
      exports: ["loginLimiter", "signupLimiter"]
      min_lines: 40
    - path: "src/index.ts"
      provides: "Main application mounting auth routes"
      contains: "app.route.*auth"
  key_links:
    - from: "src/routes/auth.ts"
      to: "src/auth/config.ts"
      via: "Import auth instance and mount handler"
      pattern: "auth\\.handler"
    - from: "src/index.ts"
      to: "src/routes/auth.ts"
      via: "Mount auth router under /api/auth"
      pattern: "app\\.route.*\\/api\\/auth"
    - from: "src/middleware/auth.ts"
      to: "src/auth/config.ts"
      via: "Session verification using Better Auth API"
      pattern: "auth\\.api\\.getSession"
---

<objective>
Implement authentication API endpoints and middleware, enabling email/password and Google OAuth flows with session persistence and rate limiting.

Purpose: Allow users to sign up, log in, and authenticate via Google OAuth; protect auth endpoints from abuse; provide session-based authentication for protected routes.

Output: Working auth API at /api/auth, authentication middleware, rate limiting, and session management.
</objective>

<execution_context>
@/home/rachel/.claude/get-shit-done/workflows/execute-plan.md
@/home/rachel/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/REQUIREMENTS.md
@.planning/phases/01-authentication-user-foundation/01-RESEARCH.md
@.planning/phases/01-authentication-user-foundation/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Create rate limiting middleware for auth endpoints</name>
  <files>
src/middleware/rate-limit.ts
  </files>
  <action>
Implement rate limiting using hono-rate-limiter to protect authentication endpoints:

**loginLimiter configuration:**
- windowMs: 15 * 60 * 1000 (15 minutes)
- limit: 5 (5 login attempts per window)
- standardHeaders: "draft-6" (include RateLimit-* headers)
- keyGenerator: Combine IP + email for granular limiting
  - Extract email from request body or query
  - Extract IP from x-forwarded-for or x-real-ip headers
  - Format: `${ip}:${email}` for unique key per IP/email combination
  - Fallback to "unknown" if IP not available

**signupLimiter configuration:**
- windowMs: 60 * 60 * 1000 (1 hour)
- limit: 3 (3 signups per hour per IP)
- standardHeaders: "draft-6"
- keyGenerator: Use IP only (prevent mass signups from single IP)
  - Extract from x-forwarded-for or x-real-ip headers
  - Fallback to "unknown"

Export both limiters as named exports.

Follow pattern from research (01-RESEARCH.md, "Pattern 5: Rate Limiting for Auth Endpoints").
Use hono-rate-limiter package (already installed in 01-01).
  </action>
  <verify>
```bash
cd /tmp/rachel-cloud && node -e "
const { loginLimiter, signupLimiter } = require('./src/middleware/rate-limit.ts');
console.assert(typeof loginLimiter === 'function', 'loginLimiter not exported');
console.assert(typeof signupLimiter === 'function', 'signupLimiter not exported');
console.log('✓ Rate limiters configured');
"
```
Both limiters export successfully
  </verify>
  <done>
Rate limiting middleware created with login and signup limiters; IP and email-based rate limiting configured
  </done>
</task>

<task type="auto">
  <name>Create auth routes and mount Better Auth handler</name>
  <files>
src/routes/auth.ts
  </files>
  <action>
Create Hono router for authentication endpoints:

**Import dependencies:**
- Import Hono from "hono"
- Import auth from "../auth/config"
- Import loginLimiter and signupLimiter from "../middleware/rate-limit"

**Create authRouter:**
- Instantiate new Hono instance
- Mount Better Auth handler for all /api/auth/** routes
  - Handle both GET and POST methods (Better Auth requires both)
  - Use router.on(["POST", "GET"], "/auth/**", handler)
  - Handler: (c) => auth.handler(c.req.raw)
  - This mounts Better Auth's built-in endpoints: /auth/signup, /auth/login, /auth/logout, /auth/session, /auth/callback/google

**Apply rate limiting:**
- Add loginLimiter middleware to POST /auth/login
- Add signupLimiter middleware to POST /auth/signup
- Do NOT apply rate limiting to /auth/session (frequent checks) or /auth/callback/* (OAuth callbacks)

Export authRouter as default export.

Follow pattern from research (01-RESEARCH.md, "Pattern 1: Better Auth + Hono Integration").
Better Auth provides all endpoints out of the box—we just mount the handler.
  </action>
  <verify>
```bash
cd /tmp/rachel-cloud && node -e "
process.env.DATABASE_URL = 'postgresql://user:pass@localhost:5432/testdb';
process.env.GOOGLE_CLIENT_ID = 'test';
process.env.GOOGLE_CLIENT_SECRET = 'test';
const authRouter = require('./src/routes/auth.ts').default;
console.assert(authRouter !== undefined, 'authRouter not exported');
console.log('✓ Auth router created');
"
```
Auth router exports successfully with Better Auth handler mounted
  </verify>
  <done>
Auth routes created with Better Auth handler mounted; rate limiting applied to login and signup endpoints
  </done>
</task>

<task type="auto">
  <name>Create authentication middleware for protected routes</name>
  <files>
src/middleware/auth.ts
  </files>
  <action>
Create middleware to protect routes requiring authentication:

**requireAuth middleware:**
- Extract session token from cookies (Better Auth sets this automatically)
- Call auth.api.getSession({ headers: c.req.raw.headers }) to verify session
  - Better Auth API method that validates session token and returns user data
  - Returns null if session invalid or expired
- If session valid:
  - Attach user data to context: c.set("user", session.user)
  - Attach session data to context: c.set("session", session.session)
  - Call await next() to continue to route handler
- If session invalid:
  - Return 401 with { error: "Unauthorized", message: "Authentication required" }
  - DO NOT call next()

**getUserOrNull helper (optional, for routes that check auth but don't require it):**
- Similar to requireAuth but returns user data without blocking
- Call auth.api.getSession
- If valid: c.set("user", session.user) and continue
- If invalid: c.set("user", null) and continue
- Always calls next()

Export requireAuth as default export, getUserOrNull as named export.

Follow session management pattern from research (01-RESEARCH.md, "Pattern 6: Session Management with HTTP-Only Cookies").
Use Better Auth's built-in session API—do not manually parse JWT or session tokens.
  </action>
  <verify>
```bash
cd /tmp/rachel-cloud && node -e "
const { default: requireAuth, getUserOrNull } = require('./src/middleware/auth.ts');
console.assert(typeof requireAuth === 'function', 'requireAuth not exported');
console.assert(typeof getUserOrNull === 'function', 'getUserOrNull not exported');
console.log('✓ Auth middleware created');
"
```
Middleware exports successfully with session validation logic
  </verify>
  <done>
Authentication middleware created; requireAuth protects routes by validating sessions; user data attached to request context
  </done>
</task>

<task type="auto">
  <name>Mount auth routes in main application</name>
  <files>
src/index.ts
  </files>
  <action>
Create or update main Hono application to mount auth routes:

**If src/index.ts exists:**
- Import authRouter from "./routes/auth"
- Mount auth router: app.route("/api/auth", authRouter)
- Ensure app is created with: const app = new Hono()
- Ensure app is exported: export default app
- If using Bun.serve, export app and serve on port 3000 with fetch: app.fetch

**If src/index.ts does NOT exist:**
- Create new file with Hono app
- Import Hono from "hono"
- Import authRouter from "./routes/auth"
- Create app: const app = new Hono()
- Mount auth router: app.route("/api/auth", authRouter)
- Add health check route: app.get("/health", (c) => c.json({ status: "ok" }))
- Export app: export default app
- Add Bun.serve:
  ```typescript
  Bun.serve({
    port: process.env.PORT || 3000,
    fetch: app.fetch,
  });
  ```

**CORS configuration (if needed for frontend):**
- Import cors from "hono/cors"
- Add app.use("*", cors({ origin: process.env.FRONTEND_URL || "http://localhost:5173", credentials: true }))
- Place BEFORE auth routes to ensure preflight requests work

Export app as default.
  </action>
  <verify>
```bash
cd /tmp/rachel-cloud && bun run src/index.ts &
sleep 2
curl -s http://localhost:3000/health | grep -q "ok"
curl -s http://localhost:3000/api/auth/session | grep -q "user"
kill %1
```
Server starts, health check responds, auth session endpoint accessible
  </verify>
  <done>
Main application created with auth routes mounted at /api/auth; server starts and responds to requests
  </done>
</task>

</tasks>

<verification>
1. Start server: `bun run src/index.ts`
2. Test health: `curl http://localhost:3000/health` returns 200
3. Test signup: `curl -X POST http://localhost:3000/api/auth/signup -H "Content-Type: application/json" -d '{"email":"test@example.com","password":"password123","name":"Test User"}'` returns success or user exists error
4. Test login: `curl -X POST http://localhost:3000/api/auth/login -H "Content-Type: application/json" -d '{"email":"test@example.com","password":"password123"}' -c cookies.txt` returns session cookie
5. Test session: `curl http://localhost:3000/api/auth/session -b cookies.txt` returns user data
6. Test rate limiting: Make 6 login requests rapidly—6th should return 429 Too Many Requests
7. Test Google OAuth: Visit `http://localhost:3000/api/auth/signin/google` redirects to Google OAuth consent screen
</verification>

<success_criteria>
- Email/password signup endpoint creates users in database
- Email/password login endpoint returns session cookies
- Google OAuth flow redirects to Google consent screen
- Session endpoint returns user data for authenticated requests
- Rate limiting blocks excessive login and signup attempts
- Protected routes using requireAuth middleware reject unauthenticated requests
- Requirements AUTH-01, AUTH-02, and AUTH-03 are fully implemented
</success_criteria>

<output>
After completion, create `.planning/phases/01-authentication-user-foundation/01-02-SUMMARY.md` documenting:
- Auth API endpoint structure and available routes
- Rate limiting configuration and limits applied
- Session management flow and cookie settings
- Testing results for signup, login, and OAuth flows
- Any issues with Better Auth integration or middleware
</output>
