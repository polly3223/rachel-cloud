---
phase: 01-authentication-user-foundation
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/routes/api/auth/[...all]/+server.ts
  - src/routes/login/+page.svelte
  - src/routes/signup/+page.svelte
  - src/routes/auth/callback/+page.svelte
  - src/lib/auth/rate-limit.ts
  - src/lib/auth/session.ts
autonomous: true

must_haves:
  truths:
    - "User can sign up with email and password"
    - "User can log in with email and password"
    - "User can authenticate with Google OAuth"
    - "Sessions persist via HTTP-only cookies"
    - "Auth endpoints are rate-limited to prevent abuse"
  artifacts:
    - path: "src/routes/api/auth/[...all]/+server.ts"
      provides: "Better Auth API routes for all auth operations"
      exports: ["GET", "POST"]
      min_lines: 10
    - path: "src/routes/login/+page.svelte"
      provides: "Login page with email/password and Google OAuth button"
      min_lines: 40
    - path: "src/routes/signup/+page.svelte"
      provides: "Signup page with email/password and Google OAuth button"
      min_lines: 40
    - path: "src/lib/auth/rate-limit.ts"
      provides: "Rate limiting middleware for auth endpoints"
      exports: ["rateLimitMiddleware"]
      min_lines: 30
    - path: "src/lib/auth/session.ts"
      provides: "Session helpers for SvelteKit load functions"
      exports: ["getSession", "requireAuth"]
      min_lines: 20
  key_links:
    - from: "src/routes/api/auth/[...all]/+server.ts"
      to: "src/lib/auth/config.ts"
      via: "imports auth instance"
      pattern: "import.*auth.*from.*config"
    - from: "src/routes/login/+page.svelte"
      to: "/api/auth/sign-in"
      via: "form submission"
      pattern: "fetch.*api/auth"
    - from: "src/lib/auth/session.ts"
      to: "src/lib/auth/config.ts"
      via: "validates session using auth client"
      pattern: "auth\\.api\\.getSession"
---

<objective>
Implement email/password authentication, Google OAuth, and session management with Better Auth.

Purpose: Enable users to sign up and log in via email/password or Google OAuth, with secure session persistence via HTTP-only cookies and rate limiting to prevent abuse.

Output: Working authentication pages and API routes that allow users to register, log in, and maintain sessions across page refreshes.
</objective>

<execution_context>
@/home/rachel/.claude/get-shit-done/workflows/execute-plan.md
@/home/rachel/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@/tmp/rachel-cloud/.planning/PROJECT.md
@/tmp/rachel-cloud/.planning/ROADMAP.md
@/tmp/rachel-cloud/.planning/phases/01-authentication-user-foundation/01-CONTEXT.md
@/tmp/rachel-cloud/.planning/phases/01-authentication-user-foundation/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Better Auth API routes and rate limiting</name>
  <files>
    src/routes/api/auth/[...all]/+server.ts
    src/lib/auth/rate-limit.ts
  </files>
  <action>
**src/routes/api/auth/[...all]/+server.ts:**
- Import `auth` from lib/auth/config
- Import `rateLimitMiddleware` from lib/auth/rate-limit
- Export GET and POST handlers that:
  - Apply rate limiting middleware (10 requests per minute per IP for auth endpoints)
  - Delegate to auth.handler(event) from Better Auth
  - Return response with Set-Cookie headers for session management
- Better Auth will handle all /api/auth/* routes (sign-in, sign-up, sign-out, callback, session, etc.)

**src/lib/auth/rate-limit.ts:**
- Implement in-memory rate limiter (Map of IP -> request timestamps)
- `rateLimitMiddleware(event: RequestEvent, limit: number, window: number)`:
  - Extract IP from event.getClientAddress()
  - Check request count within time window
  - If exceeded, throw error with 429 status
  - Clean up old entries periodically
- Export middleware function
- Note: Use simple in-memory Map for now (not Redis) since this is bootstrap phase
  </action>
  <verify>
Run `bun run dev` and curl the following to verify:
- POST http://localhost:5173/api/auth/sign-up with {email, password, name} returns 200 and Set-Cookie header
- POST http://localhost:5173/api/auth/sign-in with {email, password} returns 200 and session cookie
- GET http://localhost:5173/api/auth/session returns current session data
- Send 11 rapid requests to any auth endpoint and verify 11th returns 429 Too Many Requests
  </verify>
  <done>
Better Auth API routes handle all authentication operations, rate limiting prevents abuse (10 req/min per IP), sessions are created with HTTP-only cookies, all standard auth endpoints respond correctly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create session helpers for SvelteKit load functions</name>
  <files>
    src/lib/auth/session.ts
    src/hooks.server.ts
  </files>
  <action>
**src/lib/auth/session.ts:**
- Import `auth` from lib/auth/config
- Implement `getSession(event: RequestEvent)`:
  - Extract session cookie from event.cookies
  - Call auth.api.getSession({ headers: event.request.headers })
  - Return session object or null
- Implement `requireAuth(event: RequestEvent)`:
  - Call getSession(event)
  - If null, throw redirect(302, "/login")
  - Return session
- Export both helpers

**src/hooks.server.ts (update):**
- Extend existing handle function to attach session to event.locals:
  - Call getSession(event)
  - Set event.locals.session = session
  - This makes session available to all load functions via locals
- Keep existing auth.handler() integration
  </action>
  <verify>
Create a test route at src/routes/protected/+page.server.ts that uses requireAuth in load function. Access it without logging in and verify redirect to /login. Log in and verify access is granted.
  </verify>
  <done>
Session helpers available for all SvelteKit routes, getSession() retrieves current user session, requireAuth() enforces authentication with automatic redirect, session attached to event.locals for easy access in load functions.
  </done>
</task>

<task type="auto">
  <name>Task 3: Build login, signup, and callback pages</name>
  <files>
    src/routes/login/+page.svelte
    src/routes/signup/+page.svelte
    src/routes/auth/callback/+page.svelte
    src/routes/+layout.svelte
  </files>
  <action>
**src/routes/signup/+page.svelte:**
- Create form with fields: name, email, password
- On submit, POST to /api/auth/sign-up with fetch
- Handle success: redirect to /dashboard
- Handle errors: display error message (email already exists, weak password, etc.)
- Add "Sign up with Google" button that redirects to /api/auth/sign-in/google
- Add link to /login for existing users
- Use basic Tailwind CSS for styling (clean, minimal)

**src/routes/login/+page.svelte:**
- Create form with fields: email, password
- On submit, POST to /api/auth/sign-in with fetch
- Handle success: redirect to /dashboard
- Handle errors: display error message (invalid credentials, etc.)
- Add "Sign in with Google" button that redirects to /api/auth/sign-in/google
- Add link to /signup for new users
- Use basic Tailwind CSS for styling

**src/routes/auth/callback/+page.svelte:**
- Handle OAuth callback from Google
- Display loading state while Better Auth processes callback
- Redirect to /dashboard on success
- Display error if callback fails
- Better Auth handles the actual token exchange automatically

**src/routes/+layout.svelte (create if missing):**
- Basic layout wrapper
- Include Tailwind CSS via CDN (for now, proper setup in later phase)
- No navigation yet (auth flow only)
  </action>
  <verify>
Test full authentication flow:
1. Visit http://localhost:5173/signup, create account with email/password, verify redirect to dashboard
2. Log out, visit /login, log in with same credentials, verify redirect to dashboard
3. Click "Sign up with Google", complete OAuth flow, verify redirect to dashboard
4. Check database with `bun run drizzle-kit studio` and verify users, sessions, and accounts records exist
5. Refresh page and verify session persists (no re-login required)
  </verify>
  <done>
Users can sign up with email/password or Google OAuth, users can log in with email/password or Google OAuth, sessions persist across page refreshes via HTTP-only cookies, all auth pages styled and functional, OAuth callback handled automatically by Better Auth.
  </done>
</task>

</tasks>

<verification>
1. Sign up with email/password and verify user appears in database
2. Log in with email/password and verify session cookie is set
3. Refresh page and verify session persists without re-authentication
4. Test Google OAuth signup flow end-to-end
5. Attempt 11 rapid auth requests and verify rate limiting triggers
6. Access protected route without session and verify redirect to /login
7. Check that all session cookies are HTTP-only and secure in production
</verification>

<success_criteria>
- Email/password signup and login work end-to-end
- Google OAuth signup and login work end-to-end
- Sessions persist across page refreshes for 7 days
- Rate limiting prevents auth endpoint abuse (10 req/min per IP)
- Session helpers make authentication checks trivial in load functions
- All auth pages are styled and user-friendly
- No console errors or warnings during auth flows
</success_criteria>

<output>
After completion, create `.planning/phases/01-authentication-user-foundation/01-02-SUMMARY.md`
</output>
