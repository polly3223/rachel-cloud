---
phase: 03-vps-provisioning
plan: 04
type: execute
wave: 3
depends_on: [03-01, 03-02, 03-03]
files_modified:
  - src/lib/provisioning/provision-vps.ts
  - src/lib/provisioning/deprovision-vps.ts
  - src/lib/jobs/grace-period-enforcer.ts
  - src/routes/(authenticated)/dashboard/+page.svelte
  - src/routes/api/provision/deploy/+server.ts
autonomous: true

must_haves:
  truths:
    - "User clicks Deploy button and VPS provisioning starts"
    - "System coordinates: create server → wait for cloud-init → inject secrets → validate"
    - "Failed provisions clean up zombie VPS instances automatically"
    - "Grace period enforcer calls real deprovision logic"
    - "Dashboard shows provisioning progress and errors"
  artifacts:
    - path: "src/lib/provisioning/provision-vps.ts"
      provides: "Main provisioning orchestrator"
      exports: ["provisionVPS"]
      min_lines: 150
    - path: "src/lib/provisioning/deprovision-vps.ts"
      provides: "VPS deletion and cleanup"
      exports: ["deprovisionVPS"]
      min_lines: 50
    - path: "src/lib/jobs/grace-period-enforcer.ts"
      provides: "Updated with real deprovision call"
      contains: "import { deprovisionVPS }"
    - path: "src/routes/(authenticated)/dashboard/+page.svelte"
      provides: "Deploy button and provisioning status"
      contains: "Deploy Rachel"
    - path: "src/routes/api/provision/deploy/+server.ts"
      provides: "API endpoint to trigger provisioning"
      exports: ["POST"]
  key_links:
    - from: "src/routes/(authenticated)/dashboard/+page.svelte"
      to: "/api/provision/deploy"
      via: "fetch POST on Deploy button click"
      pattern: "fetch.*api/provision/deploy"
    - from: "src/routes/api/provision/deploy/+server.ts"
      to: "src/lib/provisioning/provision-vps.ts"
      via: "provisionVPS function call"
      pattern: "import.*provisionVPS"
    - from: "src/lib/provisioning/provision-vps.ts"
      to: "src/lib/provisioning/hetzner-client.ts"
      via: "HetznerClient API calls"
      pattern: "hetznerClient\\.(createServer|deleteServer)"
    - from: "src/lib/jobs/grace-period-enforcer.ts"
      to: "src/lib/provisioning/deprovision-vps.ts"
      via: "deprovisionVPS function call"
      pattern: "await deprovisionVPS"
---

<objective>
Implement main provisioning orchestrator that coordinates VPS creation, cloud-init, secret injection, and validation. Replace deprovision stub with real Hetzner API cleanup. Add Deploy button to dashboard.

Purpose: Complete end-to-end provisioning flow from user action to running Rachel8 instance in under 2 minutes.
Output: Working Deploy button, provisioning orchestrator, deprovisioning cleanup, integrated with Phase 2 grace period logic.
</objective>

<execution_context>
@/home/rachel/.claude/get-shit-done/workflows/execute-plan.md
@/home/rachel/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-vps-provisioning/03-CONTEXT.md
@.planning/phases/03-vps-provisioning/03-RESEARCH.md
@src/lib/db/schema.ts
@src/lib/billing/subscription-manager.ts
@src/lib/jobs/grace-period-enforcer.ts
@src/lib/crypto/encryption.ts
@package.json
</context>

<tasks>

<task type="auto">
  <name>Implement main provisioning orchestrator</name>
  <files>
src/lib/provisioning/provision-vps.ts
  </files>
  <action>
Create comprehensive provisioning orchestrator following Pattern 4 from 03-RESEARCH.md:

1. Export `provisionVPS(userId: string): Promise<void>` that orchestrates full flow:

2. **Phase 1: Preparation**
   - Start timer for 2-minute SLA tracking
   - Get user's subscription from database
   - Get encrypted Claude tokens from claudeTokens table
   - Get encrypted Telegram token from telegramBots table
   - Decrypt all tokens using decryptToken from crypto/encryption.ts
   - Update provisioningStatus = 'pending' → 'creating'

3. **Phase 2: SSH Key & Hetzner Resources**
   - Generate SSH key pair using generateSSHKeyPair from ssh-keys.ts
   - Upload public key to Hetzner: createSSHKey({ name: `rachel-cloud-${userId}`, public_key })
   - Get or create firewall: check if firewall exists, if not create with rules (SSH port 22 from control plane IP only)
   - Encrypt and store private key in database (subscriptions.sshPrivateKey using encryptToken)

4. **Phase 3: VPS Creation**
   - Build cloud-init user-data using buildCloudInitUserData({ username: 'rachel', sshPublicKey, callbackUrl: `${BASE_URL}/api/provision/callback/${userId}` })
   - Create server via Hetzner API: createServer({
       name: `rachel-cloud-${userId}`,
       server_type: 'cx23',
       image: 'ubuntu-24.04',
       location: 'nbg1',
       ssh_keys: [sshKeyId],
       user_data: cloudInitYaml,
       firewalls: [{ firewall: firewallId }],
       start_after_create: true
     })
   - Store hetznerServerId, hetznerSshKeyId, vpsIpAddress in database
   - Update provisioningStatus = 'creating' → 'cloud_init'

5. **Phase 4: Wait for Cloud-Init**
   - Poll database every 2 seconds checking if provisioningStatus changed to 'injecting_secrets' (set by callback endpoint)
   - Use exponential backoff: 2s, 4s, 8s, max 16s
   - Timeout after 120 seconds (2-minute total SLA)
   - If timeout, throw error (cleanup will happen in catch block)

6. **Phase 5: Secret Injection**
   - Decrypt SSH private key from database
   - Call injectSecrets from ssh-injector.ts with:
     - host: vpsIpAddress
     - username: 'rachel'
     - privateKey: decrypted SSH key
     - claudeAccessToken, claudeRefreshToken, claudeExpiresAt
     - telegramBotToken, ownerTelegramUserId
   - Update provisioningStatus = 'injecting_secrets' → 'ready'

7. **Phase 6: Finalization**
   - Set vpsProvisioned = true, provisionedAt = now()
   - Log total elapsed time
   - If elapsed > 120000ms, log warning (SLA miss)

8. **Error Handling (try/catch/finally)**
   - Wrap entire flow in try/catch
   - On error:
     - Log error with full context
     - Call cleanupFailedProvision(userId) - deletes server, SSH key, updates DB
     - Set provisioningStatus = 'failed', provisioningError = error.message
     - Re-throw error
   - In finally: clear sensitive data from memory (tokens)

9. **cleanupFailedProvision helper function**:
   - Get subscription from DB
   - If hetznerServerId exists: deleteServer(serverId)
   - If hetznerSshKeyId exists: deleteSSHKey(keyId)
   - Update DB: vpsProvisioned = false, provisioningStatus = 'failed'
   - Log cleanup completion

Use research code structure but ensure all steps match Rachel8 requirements from CONTEXT.md.

CRITICAL: Ensure 2-minute SLA by using aggressive timeouts and parallel operations where possible.
  </action>
  <verify>
TypeScript compilation succeeds
All database updates use proper Drizzle syntax
Error handling includes cleanup of Hetzner resources
Token decryption/encryption uses existing crypto utilities
Provisioning completes within 2 minutes in happy path
  </verify>
  <done>
Provisioning orchestrator successfully coordinates all phases from VPS creation to running Rachel8 service with proper error handling and cleanup
  </done>
</task>

<task type="auto">
  <name>Implement deprovisioning and replace stub</name>
  <files>
src/lib/provisioning/deprovision-vps.ts
src/lib/jobs/grace-period-enforcer.ts
  </files>
  <action>
1. Create src/lib/provisioning/deprovision-vps.ts:

Export `deprovisionVPS(userId: string): Promise<void>` that:
   - Get subscription from database (include hetznerServerId, hetznerSshKeyId)
   - If no subscription or not provisioned, log warning and return
   - Delete Hetzner server: hetznerClient.deleteServer(hetznerServerId)
   - Delete SSH key: hetznerClient.deleteSSHKey(hetznerSshKeyId)
   - Update database:
     - vpsProvisioned = false
     - hetznerServerId = null
     - hetznerSshKeyId = null
     - vpsIpAddress = null
     - vpsHostname = null
     - provisioningStatus = null
     - deprovisionedAt = now()
     - sshPrivateKey = null
   - Log successful deprovisioning with userId
   - Error handling:
     - If Hetzner API fails with 404 (server already deleted), log and continue
     - If other error, log but still update database to prevent zombie records
     - Always update database even if Hetzner calls fail

2. Update src/lib/jobs/grace-period-enforcer.ts:
   - Replace stub `deprovisionVPS` function with: `import { deprovisionVPS } from '$lib/provisioning/deprovision-vps';`
   - Remove the local stub function definition (lines 113-121)
   - The existing call at line 53 will now use the real implementation

Ensure deprovisioning is idempotent - safe to call multiple times.
  </action>
  <verify>
TypeScript compilation succeeds
grace-period-enforcer.ts imports real deprovisionVPS
Deprovisioning handles 404 errors gracefully (server already gone)
Database is always updated even if Hetzner API fails
All fields are properly nulled in database
  </verify>
  <done>
Real deprovisioning implementation cleans up Hetzner resources and updates database, integrated with grace period enforcer from Phase 2
  </done>
</task>

<task type="auto">
  <name>Add Deploy button and provisioning API endpoint</name>
  <files>
src/routes/api/provision/deploy/+server.ts
src/routes/(authenticated)/dashboard/+page.svelte
  </files>
  <action>
1. Create src/routes/api/provision/deploy/+server.ts:

Export POST handler that:
   - Require authentication using requireAuth from $lib/auth/session
   - Get userId from session
   - Validate user has active subscription (status = 'active')
   - Validate user has completed onboarding (Telegram bot token exists)
   - Check if already provisioned (vpsProvisioned = true):
     - If yes, return 400 error "VPS already provisioned"
   - Call provisionVPS(userId) - don't await, return immediately
   - Return 202 Accepted with { message: "Provisioning started" }
   - Error handling:
     - 400 if subscription not active or Telegram token missing
     - 500 if provisionVPS throws (but this shouldn't happen since we don't await)

2. Update src/routes/(authenticated)/dashboard/+page.svelte:

Add provisioning section to dashboard:
   - Load user's subscription status in +page.server.ts using requireAuth and getSubscription
   - Show different UI based on provisioningStatus:
     - If null or 'none': Show "Deploy Rachel" button (primary CTA)
     - If 'pending', 'creating', 'cloud_init', 'injecting_secrets': Show spinner + status message
     - If 'ready': Show "Rachel is running" with VPS IP address
     - If 'failed': Show error message with provisioningError text + "Retry" button
   - Deploy button onClick:
     - POST to /api/provision/deploy
     - Show loading state
     - On 202: Poll subscription status every 2 seconds
     - On 400/500: Show error message
   - Status messages:
     - pending: "Preparing your VPS..."
     - creating: "Creating server on Hetzner..."
     - cloud_init: "Installing software and configuring system..."
     - injecting_secrets: "Connecting your Claude and Telegram accounts..."
     - ready: "✓ Rachel is running on Telegram!"

Use existing dashboard layout from Phase 2 as reference. Add this section after subscription status.

IMPORTANT: provisionVPS runs async in background. Don't block API response waiting for completion. Use polling from client to show progress.
  </action>
  <verify>
TypeScript compilation succeeds for both files
Deploy button appears when subscription is active and VPS not provisioned
API endpoint validates subscription status before provisioning
Provisioning runs in background without blocking response
Client polls for status updates and shows progress
Error states show actionable messages to user
  </verify>
  <done>
Dashboard shows Deploy button, API endpoint triggers provisioning, UI displays real-time progress and handles all provisioning states
  </done>
</task>

</tasks>

<verification>
1. Provisioning orchestrator coordinates all phases in correct order
2. Cleanup happens automatically on provisioning failures
3. Deprovisioning removes Hetzner resources and updates database
4. Deploy button triggers provisioning and shows progress
5. All error states have clear user-facing messages
</verification>

<success_criteria>
1. User can click Deploy and see VPS provisioning progress
2. Provisioning completes in under 2 minutes for happy path
3. Failed provisions clean up zombie servers automatically
4. Grace period enforcer uses real deprovision logic
5. Dashboard shows provisioning status with meaningful messages
6. All database fields properly updated throughout lifecycle
</success_criteria>

<output>
After completion, create `.planning/phases/03-vps-provisioning/03-04-SUMMARY.md`
</output>
