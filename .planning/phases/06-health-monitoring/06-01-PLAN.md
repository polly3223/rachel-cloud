---
phase: 06-health-monitoring
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/db/schema.ts
  - src/lib/monitoring/health-checker.ts
  - src/lib/monitoring/circuit-breaker.ts
  - src/hooks.server.ts
autonomous: true

must_haves:
  truths:
    - "Health check job runs every 60 seconds and checks all active VPSs"
    - "Health state (consecutive failures, circuit breaker state) persists in database across server restarts"
    - "Circuit breaker trips after 3 consecutive failures and stops auto-restart attempts"
    - "Health check does not block user requests or overlap with previous sweep"
  artifacts:
    - path: "src/lib/db/schema.ts"
      provides: "healthChecks table schema"
      contains: "healthChecks"
    - path: "src/lib/monitoring/health-checker.ts"
      provides: "Health check sweep logic and scheduling"
      exports: ["startHealthMonitor", "stopHealthMonitor"]
    - path: "src/lib/monitoring/circuit-breaker.ts"
      provides: "Circuit breaker state machine logic"
      exports: ["CircuitBreakerState", "shouldAttemptRestart", "recordFailure", "recordSuccess", "resetCircuitBreaker"]
  key_links:
    - from: "src/lib/monitoring/health-checker.ts"
      to: "src/lib/provisioning/ssh-exec.ts"
      via: "execSSHCommand for health check"
      pattern: "execSSHCommand"
    - from: "src/lib/monitoring/health-checker.ts"
      to: "src/lib/db/schema.ts"
      via: "healthChecks table for state persistence"
      pattern: "healthChecks"
    - from: "src/hooks.server.ts"
      to: "src/lib/monitoring/health-checker.ts"
      via: "startHealthMonitor() call on server startup"
      pattern: "startHealthMonitor"
---

<objective>
Add the database schema for health tracking and implement the core health check sweep service with circuit breaker logic.

Purpose: This is the foundation for Phase 6 -- without persistent health state and a running health checker, auto-recovery and notifications (Plan 02) cannot function.
Output: A background health check job that runs every 60 seconds, checks all active VPSs via SSH, and persists health state including circuit breaker status.
</objective>

<execution_context>
@/home/rachel/.claude/get-shit-done/workflows/execute-plan.md
@/home/rachel/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/lib/db/schema.ts
@src/lib/provisioning/ssh-exec.ts
@src/lib/provisioning/vps-status.ts
@src/lib/jobs/grace-period-enforcer.ts
@src/hooks.server.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add healthChecks table to DB schema + circuit breaker module</name>
  <files>
    src/lib/db/schema.ts
    src/lib/monitoring/circuit-breaker.ts
  </files>
  <action>
    **1. Add `healthChecks` table to `src/lib/db/schema.ts`:**

    Add a new table after the existing `telegramBots` table:

    ```typescript
    export const healthChecks = sqliteTable('health_checks', {
      id: text('id').primaryKey(),
      userId: text('user_id')
        .notNull()
        .unique()
        .references(() => users.id, { onDelete: 'cascade' }),
      status: text('status', { enum: ['healthy', 'unhealthy', 'down', 'circuit_open'] })
        .notNull()
        .$defaultFn(() => 'healthy'),
      consecutiveFailures: integer('consecutive_failures')
        .notNull()
        .$defaultFn(() => 0),
      circuitState: text('circuit_state', { enum: ['closed', 'open', 'half_open'] })
        .notNull()
        .$defaultFn(() => 'closed'),
      circuitOpenedAt: integer('circuit_opened_at', { mode: 'timestamp' }),
      lastCheckAt: integer('last_check_at', { mode: 'timestamp' }),
      lastHealthyAt: integer('last_healthy_at', { mode: 'timestamp' }),
      lastFailureAt: integer('last_failure_at', { mode: 'timestamp' }),
      lastRestartAttemptAt: integer('last_restart_attempt_at', { mode: 'timestamp' }),
      lastNotifiedDownAt: integer('last_notified_down_at', { mode: 'timestamp' }),
      lastNotifiedUpAt: integer('last_notified_up_at', { mode: 'timestamp' }),
      lastError: text('last_error'),
      totalChecks: integer('total_checks')
        .notNull()
        .$defaultFn(() => 0),
      totalFailures: integer('total_failures')
        .notNull()
        .$defaultFn(() => 0),
      totalRecoveries: integer('total_recoveries')
        .notNull()
        .$defaultFn(() => 0),
      createdAt: integer('created_at', { mode: 'timestamp' })
        .$defaultFn(() => new Date())
        .notNull(),
      updatedAt: integer('updated_at', { mode: 'timestamp' })
        .$defaultFn(() => new Date())
        .$onUpdateFn(() => new Date())
        .notNull()
    });
    ```

    Field purposes:
    - `status`: Current health status for dashboard display (healthy/unhealthy/down/circuit_open)
    - `consecutiveFailures`: Counter for circuit breaker (resets on success)
    - `circuitState`: Circuit breaker FSM state (closed/open/half_open)
    - `circuitOpenedAt`: When circuit was tripped (for cooldown calculation)
    - `lastCheckAt`: Timestamp of most recent health check
    - `lastHealthyAt`: Last time the VPS was confirmed healthy
    - `lastFailureAt`: Last time a health check failed
    - `lastRestartAttemptAt`: Last time an auto-restart was attempted
    - `lastNotifiedDownAt`/`lastNotifiedUpAt`: Prevent notification spam (only notify on state transitions)
    - `lastError`: Most recent error message for debugging
    - `totalChecks`/`totalFailures`/`totalRecoveries`: Lifetime counters for metrics

    After schema change, run `bunx drizzle-kit push` to apply.

    **2. Create `src/lib/monitoring/circuit-breaker.ts`:**

    Implement a pure-logic circuit breaker module (no DB calls -- just state transition logic):

    ```typescript
    /**
     * Circuit breaker state machine for health monitoring.
     * Pure logic module -- no DB calls. Caller manages persistence.
     */

    export type CircuitState = 'closed' | 'open' | 'half_open';

    /** Max consecutive failures before tripping the circuit. */
    export const MAX_CONSECUTIVE_FAILURES = 3;

    /** Cooldown period in ms before trying again (30 minutes). */
    export const CIRCUIT_COOLDOWN_MS = 30 * 60 * 1000;

    export interface CircuitBreakerInput {
      circuitState: CircuitState;
      consecutiveFailures: number;
      circuitOpenedAt: Date | null;
    }

    /**
     * Determine if a restart should be attempted for a VPS.
     * Returns true if the circuit allows a restart attempt.
     */
    export function shouldAttemptRestart(input: CircuitBreakerInput): boolean {
      if (input.circuitState === 'closed') return true;
      if (input.circuitState === 'open') {
        // Check if cooldown has expired -> transition to half_open
        if (input.circuitOpenedAt) {
          const elapsed = Date.now() - input.circuitOpenedAt.getTime();
          if (elapsed >= CIRCUIT_COOLDOWN_MS) return true; // will become half_open
        }
        return false;
      }
      if (input.circuitState === 'half_open') return true;
      return false;
    }

    /**
     * Get the next circuit state after a failure.
     */
    export function getStateAfterFailure(input: CircuitBreakerInput): {
      circuitState: CircuitState;
      consecutiveFailures: number;
      circuitOpenedAt: Date | null;
      tripped: boolean; // true if circuit just transitioned to open
    } {
      const newFailures = input.consecutiveFailures + 1;

      if (input.circuitState === 'half_open') {
        // Failed during half_open probe -> back to open
        return {
          circuitState: 'open',
          consecutiveFailures: newFailures,
          circuitOpenedAt: new Date(),
          tripped: false, // was already tripped before
        };
      }

      if (newFailures >= MAX_CONSECUTIVE_FAILURES) {
        // Trip the circuit
        return {
          circuitState: 'open',
          consecutiveFailures: newFailures,
          circuitOpenedAt: new Date(),
          tripped: true,
        };
      }

      return {
        circuitState: 'closed',
        consecutiveFailures: newFailures,
        circuitOpenedAt: input.circuitOpenedAt,
        tripped: false,
      };
    }

    /**
     * Get the next circuit state after a success.
     */
    export function getStateAfterSuccess(input: CircuitBreakerInput): {
      circuitState: CircuitState;
      consecutiveFailures: number;
      circuitOpenedAt: null;
      recovered: boolean; // true if transitioning from non-closed to closed
    } {
      const wasDown = input.circuitState !== 'closed' || input.consecutiveFailures > 0;
      return {
        circuitState: 'closed',
        consecutiveFailures: 0,
        circuitOpenedAt: null,
        recovered: wasDown,
      };
    }

    /**
     * Determine the effective circuit state, accounting for cooldown expiry.
     * If circuit is open and cooldown expired, returns 'half_open'.
     */
    export function getEffectiveCircuitState(input: CircuitBreakerInput): CircuitState {
      if (input.circuitState === 'open' && input.circuitOpenedAt) {
        const elapsed = Date.now() - input.circuitOpenedAt.getTime();
        if (elapsed >= CIRCUIT_COOLDOWN_MS) return 'half_open';
      }
      return input.circuitState;
    }
    ```
  </action>
  <verify>
    1. Run `bunx drizzle-kit push` to verify schema applies cleanly.
    2. Verify `healthChecks` table exists: `sqlite3 [db-path] ".schema health_checks"`
    3. Run `bun run check` to verify TypeScript compiles without errors.
  </verify>
  <done>
    healthChecks table exists in the database with all columns. Circuit breaker module exports all state transition functions. TypeScript compiles without errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement health check sweep service and start on server boot</name>
  <files>
    src/lib/monitoring/health-checker.ts
    src/hooks.server.ts
  </files>
  <action>
    **1. Create `src/lib/monitoring/health-checker.ts`:**

    This module implements the core health check sweep: query all active VPSs, SSH check each one, handle failures with circuit breaker logic, and persist state.

    Key behaviors:
    - Schedule a cron job via `node-schedule` that runs every 60 seconds (`*/1 * * * *`)
    - Query DB for all subscriptions where `status = 'active' AND vpsProvisioned = true AND provisioningStatus = 'ready'`
    - For each VPS, check `systemctl is-active rachel8` via `execSSHCommand()`
    - If healthy: update healthChecks record (status='healthy', reset consecutive failures, etc.)
    - If unhealthy AND circuit breaker allows: attempt restart via `restartRachelService()`
    - If restart succeeds: mark healthy, set `recovered: true` flag (Plan 02 will send email)
    - If restart fails: increment consecutive failures, check circuit breaker
    - If circuit breaker trips: mark status='circuit_open', set `tripped: true` flag (Plan 02 will alert admin)
    - Process VPSs in batches of 5 using `Promise.allSettled()` (not `Promise.all()`)
    - Guard against overlapping sweeps with a `sweepInProgress` boolean flag
    - Log all actions with `[health-checker]` prefix

    Exports:
    - `startHealthMonitor()`: starts the cron job, called once at server startup
    - `stopHealthMonitor()`: cancels the cron job, for cleanup
    - `runHealthSweep()`: exposed for testing, runs a single sweep

    The function should upsert healthChecks records -- if no record exists for a userId, create one. Use Drizzle's `insert().onConflictDoUpdate()` pattern.

    For the SSH check, use short timeouts (10s connect, 10s command) since this is a quick liveness probe:
    ```typescript
    const result = await execSSHCommand({
      host: vps.vpsIpAddress,
      privateKey: decryptToken(vps.sshPrivateKey),
      command: 'sudo systemctl is-active rachel8',
      connectTimeoutMs: 10_000,
      commandTimeoutMs: 10_000,
    });
    const isHealthy = result.exitCode === 0 && result.stdout.trim() === 'active';
    ```

    If the SSH connection itself fails (timeout, connection refused), treat it as unhealthy but do NOT attempt restart (the VPS itself may be unreachable -- restart won't help). Only attempt restart when SSH works but the service is not active.

    Log format example:
    ```
    [health-checker] Sweep started: 12 active VPSs
    [health-checker] user-abc: healthy (check #145)
    [health-checker] user-def: unhealthy (consecutive: 2, attempting restart)
    [health-checker] user-def: restart successful, marking healthy
    [health-checker] user-ghi: circuit breaker TRIPPED (3 consecutive failures)
    [health-checker] Sweep completed in 8.2s (12 checked, 11 healthy, 1 unhealthy)
    ```

    **2. Update `src/hooks.server.ts`:**

    Import and call `startHealthMonitor()` at module level (not inside the handle function). This ensures it runs once when the server starts:

    ```typescript
    import { startHealthMonitor } from '$lib/monitoring/health-checker';

    // Start health monitoring on server boot
    // Only start if in production or if ENABLE_HEALTH_MONITOR env var is set
    if (process.env.NODE_ENV === 'production' || process.env.ENABLE_HEALTH_MONITOR === 'true') {
      startHealthMonitor();
    }
    ```

    Place this import and call BEFORE the `export const handle` function. The health monitor runs independently of the request handler.
  </action>
  <verify>
    1. Run `bun run check` to verify TypeScript compiles cleanly.
    2. Set `ENABLE_HEALTH_MONITOR=true` and run `bun run dev` -- verify log output shows `[health-checker] Health monitor started`.
    3. Verify the sweep runs after 60 seconds with log output (will show "0 active VPSs" in dev).
    4. Stop dev server -- verify no orphaned processes.
  </verify>
  <done>
    Health checker starts on server boot, runs sweeps every 60 seconds, checks VPS health via SSH, applies circuit breaker logic, persists state to healthChecks table, and logs all operations. Overlapping sweeps are prevented.
  </done>
</task>

</tasks>

<verification>
1. `bun run check` passes with no TypeScript errors
2. `bunx drizzle-kit push` applies schema without errors
3. healthChecks table has all expected columns
4. Health monitor starts when `ENABLE_HEALTH_MONITOR=true` is set
5. Circuit breaker module correctly transitions: closed -> open after 3 failures, open -> half_open after cooldown
6. No overlapping sweeps when sweep takes longer than 60 seconds
</verification>

<success_criteria>
- healthChecks table exists with all health tracking columns
- Circuit breaker module exports pure state transition functions
- Health checker runs as background job every 60 seconds
- VPS health checks use SSH with 10s timeouts
- Circuit breaker trips after 3 consecutive failures
- State persists to DB (survives server restart)
- Sweep overlap is prevented via guard flag
- Health monitor only starts in production or with explicit env var
</success_criteria>

<output>
After completion, create `.planning/phases/06-health-monitoring/06-01-SUMMARY.md`
</output>
