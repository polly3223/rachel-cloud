/**
 * SSH-based secret injection and service startup for VPS provisioning.
 *
 * After cloud-init completes the non-secret VPS setup, this module connects
 * via SSH to inject sensitive credentials and start the Rachel8 service:
 *
 * 1. Claude OAuth credentials (~/.claude/.credentials.json)
 * 2. Rachel8 environment file (~/rachel8/.env)
 * 3. systemd service installation and startup
 * 4. Service health validation
 *
 * SECURITY: Secrets are never placed in cloud-init user-data (visible in
 * Hetzner API responses). SSH injection ensures credentials are only
 * transmitted over an encrypted channel directly to the target VPS.
 *
 * @module ssh-injector
 */

import { Client } from 'ssh2';
import type { SSHInjectionConfig } from './types';

// ---------------------------------------------------------------------------
// Constants
// ---------------------------------------------------------------------------

/** SSH connection timeout in milliseconds. */
const SSH_CONNECT_TIMEOUT_MS = 30_000;

/** Maximum time to wait for a single SSH command to complete. */
const SSH_COMMAND_TIMEOUT_MS = 30_000;

// ---------------------------------------------------------------------------
// Public API
// ---------------------------------------------------------------------------

/**
 * Inject secrets into a provisioned VPS and start the Rachel8 service.
 *
 * This function performs the following steps over SSH:
 * 1. Creates ~/.claude directory
 * 2. Writes .credentials.json with Claude OAuth tokens
 * 3. Writes .env file with Telegram and runtime configuration
 * 4. Installs and starts the rachel8 systemd service
 * 5. Validates the service is running
 *
 * @param config - SSH connection details and secrets to inject
 * @throws Error if any step fails, with descriptive message including step name and stderr
 *
 * @example
 * ```typescript
 * await injectSecrets({
 *   host: '168.119.100.42',
 *   username: 'rachel',
 *   privateKey: '-----BEGIN PRIVATE KEY-----\n...',
 *   claudeAccessToken: 'sk-ant-oat01-...',
 *   claudeRefreshToken: 'sk-ant-ort01-...',
 *   claudeExpiresAt: 1748658860401,
 *   telegramBotToken: '123456:ABC-...',
 *   ownerTelegramUserId: '987654321',
 * });
 * ```
 */
export async function injectSecrets(config: SSHInjectionConfig): Promise<void> {
	const conn = new Client();

	try {
		// Establish SSH connection
		await connectSSH(conn, config);

		const home = `/home/${config.username}`;

		// Step 1: Create .claude directory
		await execCommand(
			conn,
			`mkdir -p ${home}/.claude`,
			'create .claude directory'
		);

		// Step 2: Write Claude OAuth credentials
		const credentials = JSON.stringify(
			{
				claudeAiOauth: {
					accessToken: config.claudeAccessToken,
					refreshToken: config.claudeRefreshToken,
					expiresAt: config.claudeExpiresAt,
					scopes: ['user:inference', 'user:profile']
				}
			},
			null,
			2
		);

		await execCommand(
			conn,
			`cat > ${home}/.claude/.credentials.json << 'CREDENTIALS_EOF'\n${credentials}\nCREDENTIALS_EOF`,
			'write Claude credentials'
		);

		await execCommand(
			conn,
			`chmod 600 ${home}/.claude/.credentials.json`,
			'set credentials permissions'
		);

		// Step 3: Write Rachel8 .env file
		const envContent = [
			'# Rachel8 Configuration (auto-generated by Rachel Cloud)',
			`TELEGRAM_BOT_TOKEN=${config.telegramBotToken}`,
			`OWNER_TELEGRAM_USER_ID=${config.ownerTelegramUserId}`,
			`SHARED_FOLDER_PATH=${home}/shared`,
			'NODE_ENV=production',
			'LOG_LEVEL=info'
		].join('\n');

		await execCommand(
			conn,
			`cat > ${home}/rachel8/.env << 'ENV_EOF'\n${envContent}\nENV_EOF`,
			'write .env file'
		);

		await execCommand(
			conn,
			`chmod 600 ${home}/rachel8/.env`,
			'set .env permissions'
		);

		// Step 4: Install systemd service
		await execCommand(
			conn,
			`sudo cp ${home}/rachel8/rachel8.service /etc/systemd/system/`,
			'copy systemd service file'
		);

		await execCommand(
			conn,
			'sudo systemctl daemon-reload',
			'reload systemd daemon'
		);

		await execCommand(
			conn,
			'sudo systemctl enable rachel8',
			'enable rachel8 service'
		);

		await execCommand(
			conn,
			'sudo systemctl start rachel8',
			'start rachel8 service'
		);

		// Step 5: Validate service is running
		await validateServiceRunning(conn);
	} finally {
		// Always close SSH connection
		conn.end();
	}
}

// ---------------------------------------------------------------------------
// Private helpers
// ---------------------------------------------------------------------------

/**
 * Establish an SSH connection with timeout.
 *
 * @param conn - ssh2 Client instance
 * @param config - Connection configuration
 * @returns Promise that resolves when connection is established
 */
function connectSSH(conn: Client, config: SSHInjectionConfig): Promise<void> {
	return new Promise<void>((resolve, reject) => {
		const timeout = setTimeout(() => {
			conn.end();
			reject(
				new Error(
					`SSH connection to ${config.host} timed out after ${SSH_CONNECT_TIMEOUT_MS}ms`
				)
			);
		}, SSH_CONNECT_TIMEOUT_MS);

		conn.on('ready', () => {
			clearTimeout(timeout);
			resolve();
		});

		conn.on('error', (err) => {
			clearTimeout(timeout);
			reject(
				new Error(`SSH connection to ${config.host} failed: ${err.message}`)
			);
		});

		conn.connect({
			host: config.host,
			port: 22,
			username: config.username,
			privateKey: config.privateKey,
			readyTimeout: SSH_CONNECT_TIMEOUT_MS
		});
	});
}

/**
 * Execute a command over an established SSH connection and return its stdout.
 *
 * @param conn - Connected ssh2 Client
 * @param command - Shell command to execute
 * @param stepName - Human-readable name for error messages
 * @returns Trimmed stdout output
 * @throws Error with step context if command exits with non-zero code
 */
function execCommand(
	conn: Client,
	command: string,
	stepName: string
): Promise<string> {
	return new Promise<string>((resolve, reject) => {
		const timeout = setTimeout(() => {
			reject(
				new Error(
					`SSH command timed out during "${stepName}" after ${SSH_COMMAND_TIMEOUT_MS}ms`
				)
			);
		}, SSH_COMMAND_TIMEOUT_MS);

		conn.exec(command, (err, stream) => {
			if (err) {
				clearTimeout(timeout);
				return reject(
					new Error(`SSH exec failed during "${stepName}": ${err.message}`)
				);
			}

			let stdout = '';
			let stderr = '';

			stream.on('data', (data: Buffer) => {
				stdout += data.toString();
			});

			stream.stderr.on('data', (data: Buffer) => {
				stderr += data.toString();
			});

			stream.on('close', (code: number) => {
				clearTimeout(timeout);

				if (code !== 0) {
					reject(
						new Error(
							`Command failed during "${stepName}" (exit code ${code}):\n` +
								`  Command: ${command}\n` +
								`  Stderr: ${stderr.trim() || '(empty)'}`
						)
					);
				} else {
					resolve(stdout.trim());
				}
			});
		});
	});
}

/**
 * Validate that the rachel8 systemd service is running.
 *
 * If the service is not active, reads the last 50 journal lines and
 * includes them in the error message for debugging.
 *
 * @param conn - Connected ssh2 Client
 * @throws Error if the service is not in "active" state
 */
async function validateServiceRunning(conn: Client): Promise<void> {
	const status = await execCommand(
		conn,
		'sudo systemctl is-active rachel8',
		'check service status'
	);

	if (status.trim() !== 'active') {
		// Fetch journal logs for debugging
		let logs = '';
		try {
			logs = await execCommand(
				conn,
				'journalctl -u rachel8 -n 50 --no-pager 2>/dev/null',
				'read service logs'
			);
		} catch {
			logs = '(unable to read journal logs)';
		}

		throw new Error(
			`Rachel8 service is not active (status: "${status.trim()}").\n` +
				`Journal logs:\n${logs}`
		);
	}
}
